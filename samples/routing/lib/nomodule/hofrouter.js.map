{
  "version": 3,
  "sources": ["../../node_modules/@hofjs/hofjs/lib/esm/hof.js", "../../src/hofrouter.ts", "../../src/esbuild-wrapper/hofrouter.esbuild.ts"],
  "sourcesContent": ["// https://github.com/prateek3255/typescript-react-demo-library\r\n// Adapt bind to preserve function body instead of returning [native code] if function is bound which is\r\n// important because _makeDerivedVariablesObservable requires function body to setup observability\r\n(function () {\r\n    const originalBind = Function.prototype.bind;\r\n    // Only adapt if extension has not already been applied\r\n    if (originalBind.toString().includes(\"[native code]\"))\r\n        Function.prototype.bind = function () {\r\n            const result = originalBind.apply(this, arguments);\r\n            result.toString = () => this.toString();\r\n            return result;\r\n        };\r\n}());\r\n// Shim replaceAll if not supported on browser by using a simplified implementation\r\n// that provides all required functionality for this framework\r\n(function () {\r\n    if (!String.prototype.replaceAll) {\r\n        String.prototype.replaceAll = function (find, replace) {\r\n            let s = '', index, next;\r\n            while (~(next = this.indexOf(find, index))) {\r\n                s += this.substring(index, next) + replace;\r\n                index = next + find.length;\r\n            }\r\n            return s + this.substring(index);\r\n        };\r\n    }\r\n}());\r\nclass AttributeExpression {\r\n    constructor(execute, bindVariableNames, template) {\r\n        this.execute = execute;\r\n        this.bindVariableNames = bindVariableNames;\r\n        this.template = template;\r\n    }\r\n}\r\nclass ListData {\r\n    constructor(listParentElement, listParentElementIndex, listParentElementRenderOnEmptyList, listProperty, listDerived, listFunction, listCurrentData, listItemVariable, listIndexVariable, listItemUpdatedVariable, listElementTemplateFunction, listElementTemplateSize) {\r\n        this.listParentElement = listParentElement;\r\n        this.listParentElementIndex = listParentElementIndex;\r\n        this.listParentElementRenderOnEmptyList = listParentElementRenderOnEmptyList;\r\n        this.listProperty = listProperty;\r\n        this.listDerived = listDerived;\r\n        this.listFunction = listFunction;\r\n        this.listCurrentData = listCurrentData;\r\n        this.listItemVariable = listItemVariable;\r\n        this.listIndexVariable = listIndexVariable;\r\n        this.listItemUpdatedVariable = listItemUpdatedVariable;\r\n        this.listElementTemplateFunction = listElementTemplateFunction;\r\n        this.listElementTemplateSize = listElementTemplateSize;\r\n    }\r\n}\r\nexport class HofHtmlElement extends HTMLElement {\r\n    constructor(tagName = 'div') {\r\n        super();\r\n        this._tagName = null;\r\n        this._root = null;\r\n        this._shadow = null;\r\n        this._properties = {}; // Global properties (of component)\r\n        this._derivedProperties = {}; // All derived properties with their function definition\r\n        this._allBindVariables = null; // All bind variables with their current values\r\n        this._allBindExpressions = {}; // All bind variable expressions used in templates\r\n        this._observersForBindVariable = new Map(); // Map<BindVariableName, Map<DOMElement, AttributeName[]>>\r\n        this._observerExpressions = new Map(); // Map<DOMElement, Map<AttributeName, AttributeExpression>>\r\n        this._renderIteration = -1; // Each rendering process increments id (rendering of a list of n elements means n incrementations, each update an additional one)\r\n        this._lists = new Map();\r\n        this._parentProperties = null; // Properties of HofHtmlElement to differentiate own properties of classes that extend HofHtmlElement\r\n        this._propertyReferences = new Map(); // Property names and initial values to allow property identification based on value at first rendering\r\n        this.REFERENCED_BIND_VARIABLE_NAMES_REGEX = new RegExp('([a-zA-Z_$][\\\\w]+\\\\.[\\\\w\\\\.]+[\\\\w])([\\\\.][\\\\w]+\\\\()?', 'g');\r\n        this.styles = null;\r\n        this._tagName = tagName;\r\n        this._shadow = this.attachShadow({ mode: \"open\" });\r\n        this._parentProperties = Object.getOwnPropertyNames(this);\r\n        this._makeDerivedPropertyFunctions();\r\n    }\r\n    connectedCallback() {\r\n        this._root = document.createElement(this._tagName);\r\n        this._shadow.appendChild(this._root);\r\n        if (this.styles != null) {\r\n            const styles = document.createElement(\"style\");\r\n            styles.innerHTML = this.styles;\r\n            this._shadow.appendChild(styles);\r\n        }\r\n        this._makeComponentPropertiesObservable();\r\n        // If HofHtmlElement is used in plain HTML markup and not within other HofHtmlElement,\r\n        // full render has to be called because no other HofHtmlElement manages call to render\r\n        if (this._isRootHofHtmlElement())\r\n            this.render();\r\n    }\r\n    render() {\r\n        // This method only gets called one time for each component instance because after\r\n        // rendering \r\n        for (const template of this.templates) {\r\n            if (Array.isArray(template)) {\r\n                const listPropertyName = this._findPropertyForValue(template[0]);\r\n                const restoredGetter = this._restoreDerivedPropertyFunction(listPropertyName);\r\n                const listParentElementName = template[2];\r\n                const renderParentElementOnEmptyList = template[3];\r\n                // Derived property? -> Resolve\r\n                const listPropertyFunction = this._derivedProperties[listPropertyName] ?\r\n                    restoredGetter : new Function(`return this.${listPropertyName};`).bind(this);\r\n                this._renderList(listPropertyFunction, template[1], listParentElementName, renderParentElementOnEmptyList);\r\n            }\r\n            else\r\n                this._renderContent(template);\r\n        }\r\n        // Property references are no longer needed because resolving is completed\r\n        this._propertyReferences = null;\r\n    }\r\n    _isRootHofHtmlElement() {\r\n        // Look for HofHtmlElements above this HofHtmlElement\r\n        for (let node = this; node; node = node.parentNode)\r\n            if (node.toString() === \"[object ShadowRoot]\" && node[\"host\"] instanceof HofHtmlElement)\r\n                return false; // HofHtmlElement that contains this HofHtmlElement was found\r\n        // No HofHtmlElement was found above this element -> this element is root HofHtmlElement\r\n        return true;\r\n    }\r\n    _makeDerivedPropertyFunctions() {\r\n        // Replace derived properties (properties with only a getter) with functions that return getter\r\n        // to identify properties by their value in method _findPropertyForValue (simple values do not\r\n        // work because they can be \"\" or [] which is not unique, however function references are unique)\r\n        const prototype = Object.getPrototypeOf(this);\r\n        for (const name of Object.getOwnPropertyNames(prototype).filter(name => name != \"constructor\")) {\r\n            if (Object.getOwnPropertyDescriptor(prototype, name).get) {\r\n                Object.defineProperty(this, name, {\r\n                    get: function () { return Object.getOwnPropertyDescriptor(prototype, name).get; },\r\n                    configurable: true\r\n                });\r\n                this._derivedProperties[name] = Object.getOwnPropertyDescriptor(prototype, name).get;\r\n            }\r\n        }\r\n    }\r\n    _restoreDerivedPropertyFunction(listPropertyName) {\r\n        const prototype = Object.getPrototypeOf(this);\r\n        const propDesc = Object.getOwnPropertyDescriptor(prototype, listPropertyName);\r\n        if (this._derivedProperties[listPropertyName]) {\r\n            if (propDesc.get) {\r\n                Object.defineProperty(this, listPropertyName, {\r\n                    get: this._derivedProperties[listPropertyName]\r\n                });\r\n                return Object.getOwnPropertyDescriptor(prototype, listPropertyName).get.bind(this);\r\n            }\r\n        }\r\n    }\r\n    _findPropertyForValue(propertyValue) {\r\n        if (propertyValue == null)\r\n            return null;\r\n        for (const name of Object.getOwnPropertyNames(this))\r\n            if (propertyValue == this[name] || propertyValue == this._propertyReferences.get(name))\r\n                return name;\r\n        for (const name of Object.getOwnPropertyNames(Object.getPrototypeOf(this)))\r\n            if (propertyValue == this[name] || propertyValue == this._propertyReferences.get(name))\r\n                return name;\r\n        throw Error(\"Property could not be resolved! If you used a private property with leading #, \"\r\n            + \"please replace it with _, because private properties are currently not supported!\");\r\n    }\r\n    _makeComponentPropertiesObservable() {\r\n        // Replace all public simple properties with getters and setters,\r\n        // so that access can be intercepted and observability can be realized\r\n        this._forEachNonDerivedProperty((prop, obj) => {\r\n            const initialValue = obj[prop];\r\n            // Save property value for later property resolving\r\n            this._propertyReferences.set(prop, initialValue);\r\n            // Replace property with observability supporting property\r\n            Object.defineProperty(this, prop, {\r\n                get: function () { return this._getProperty(prop, initialValue); },\r\n                set: function (value) {\r\n                    const oldValue = this._getProperty(prop, initialValue);\r\n                    if (this._callBindVariableBeforeChangedHook(this, prop, value, oldValue)) {\r\n                        this._setProperty(prop, value);\r\n                        this._callBindVariableAfterChangedHook(this, prop, value, oldValue);\r\n                    }\r\n                },\r\n                enumerable: true,\r\n                configurable: true\r\n            });\r\n        });\r\n    }\r\n    _setProperty(name, value) {\r\n        const oldValue = this._properties[name];\r\n        // Update property in case of complex object (because part of it has changed) or on value change of simple property or on collection action\r\n        if (typeof (oldValue) == \"object\" || typeof (value) == \"object\" || oldValue != value || value[\"lastActionMethod\"]) {\r\n            // Only update property if it was changed and not only subproperty\r\n            if (!value.lastActionPropertyPath) {\r\n                // Process initial element-property setter calls (cache for time after template\r\n                // has been constructed and further binding variables are available)\r\n                this._properties[name] = value;\r\n                // Update properties including local binding variables\r\n                if (this._allBindVariables)\r\n                    this._allBindVariables[name] = value;\r\n            }\r\n            HofLogging.logPropertyUpdate(this, name, value);\r\n        }\r\n        // Make new objects observable\r\n        if (this._allBindVariables)\r\n            this._makeBindVariableObservable(name);\r\n        // Inform observers on property update\r\n        this._updatePropertyObservers([name, value]);\r\n        // Render update\r\n        this._renderUpdate(name, value, oldValue);\r\n    }\r\n    _getProperty(name, initialValue = undefined) {\r\n        var _a, _b;\r\n        if (this._allBindVariables)\r\n            return this._allBindVariables[name];\r\n        return (_b = (_a = this._properties[name]) !== null && _a !== void 0 ? _a : this.getAttribute(name)) !== null && _b !== void 0 ? _b : initialValue;\r\n    }\r\n    _renderContent(html) {\r\n        this._renderFull(this._root, html, null);\r\n        HofLogging.logInitialRendering(this, this._renderIteration, this._properties);\r\n    }\r\n    _renderList(listFunction, listElementTemplateFunction, listParentElementName, listParentElementRenderOnEmptyList) {\r\n        const expression = listElementTemplateFunction.toString();\r\n        // Extract variable names for item and index from list element template function, e.g. (person, index) => ...\r\n        // (list parameter has to be identified by =>, because some browsers/node return parameter without brackets in function.toString())\r\n        const [listItemVariable, listIndexVariable, listItemUpdatedVariable] = expression.substring(0, expression.indexOf(\"=>\"))\r\n            .replace(\"(\", \"\").replace(\")\", \"\").split(\",\").map(x => x.trim());\r\n        // Support derived properties as list parameters\r\n        const listExpression = listFunction.toString();\r\n        const listData = listFunction.call(this);\r\n        const listParentElementIndex = this._root.childNodes.length;\r\n        // Calculate variable names\r\n        const listReferencedProps = [];\r\n        for (const [, prop] of listExpression.matchAll(/this\\.(\\w+)/gm))\r\n            listReferencedProps.push(prop);\r\n        const listDerived = listExpression.startsWith(\"get \");\r\n        const listProperty = listDerived\r\n            ? listFunction.name.replace(\"bound get\", \"\").trim() // derived property name\r\n            : listReferencedProps[0];\r\n        let i = 0;\r\n        const locals = {};\r\n        const listParentElement = document.createElement(listParentElementName);\r\n        for (const listItem of listData) {\r\n            locals[listItemVariable] = listItem;\r\n            locals[listItemVariable]._observableUniqueName = listItemVariable + \"__it\" + (this._renderIteration + 1);\r\n            if (listIndexVariable)\r\n                locals[listIndexVariable] = i;\r\n            if (listItemUpdatedVariable)\r\n                locals[listItemUpdatedVariable] = false;\r\n            this._renderFull(listParentElement, listElementTemplateFunction, locals);\r\n            i++;\r\n        }\r\n        // Render parent element depending on list size\r\n        if (listParentElementRenderOnEmptyList || listData.length > 0)\r\n            this._root.appendChild(listParentElement);\r\n        HofLogging.logInitialRendering(this, this._renderIteration, this._properties);\r\n        const listElementTemplateSize = i > 0\r\n            ? listParentElement.childNodes.length / i\r\n            : this._parseHTML(listElementTemplateFunction, locals)[0].length;\r\n        // Create entry for list properties\r\n        for (const listProp of listReferencedProps) {\r\n            if (!this._lists.has(listProp))\r\n                this._lists.set(listProp, []);\r\n            this._lists.get(listProp).push(new ListData(listParentElement, listParentElementIndex, listParentElementRenderOnEmptyList, listProperty, listDerived, listFunction, [...listData], listItemVariable, listIndexVariable, listItemUpdatedVariable, listElementTemplateFunction, listElementTemplateSize));\r\n        }\r\n    }\r\n    _calculateBindVariables() {\r\n        let result = {};\r\n        this._forEachNonDerivedProperty((prop, obj) => result[prop] = obj[prop]);\r\n        this._allBindVariables = result;\r\n    }\r\n    _forEachNonDerivedProperty(func) {\r\n        for (const name of Object.getOwnPropertyNames(this).filter(p => !this._parentProperties.includes(p))) {\r\n            const propDesc = Object.getOwnPropertyDescriptor(this, name);\r\n            if (!propDesc.get || propDesc.configurable)\r\n                func(name, this);\r\n        }\r\n        const prototype = Object.getPrototypeOf(this);\r\n        for (const name of Object.getOwnPropertyNames(prototype).filter(p => p != \"constructor\")) {\r\n            if (!Object.getOwnPropertyDescriptor(prototype, name).get)\r\n                func(name, prototype);\r\n        }\r\n    }\r\n    _forEachProperty(func, onlyNonDerivedProperties) {\r\n        for (const name of Object.getOwnPropertyNames(this).filter(p => !this._parentProperties.includes(p))) {\r\n            const propDesc = Object.getOwnPropertyDescriptor(this, name);\r\n            if (!propDesc.get || propDesc.configurable)\r\n                func(name, this);\r\n        }\r\n        const prototype = Object.getPrototypeOf(this);\r\n        for (const name of Object.getOwnPropertyNames(prototype).filter(p => p != \"constructor\")) {\r\n            if (!onlyNonDerivedProperties || !Object.getOwnPropertyDescriptor(prototype, name).get)\r\n                func(name, this);\r\n        }\r\n    }\r\n    _convertToTemplateExpression(buildFunction) {\r\n        let expression = buildFunction.toString();\r\n        const expressionStart = expression.indexOf('`');\r\n        if (expressionStart > 0)\r\n            expression = expression.substring(expressionStart + 1, expression.length - 1);\r\n        return expression.trim();\r\n    }\r\n    _parseHTML(htmlFunction, locals) {\r\n        const html = this._convertToTemplateExpression(htmlFunction);\r\n        // First call of render?\r\n        if (this._allBindVariables == null)\r\n            this._calculateBindVariables();\r\n        const allBindVariables = this._allBindVariables;\r\n        const [template, bindVariableNames] = this._calculateTemplateAndBindVariableNames(html, allBindVariables, locals);\r\n        this._calculateBindings(template, bindVariableNames);\r\n        const parser = new DOMParser();\r\n        const elements = parser.parseFromString(template, \"text/html\").body.childNodes;\r\n        return [elements, allBindVariables, bindVariableNames];\r\n    }\r\n    _makeBindVariableObservable(bindVariableName) {\r\n        for (const bindingExpression of this._allBindExpressions[bindVariableName])\r\n            this._makeBindVariableStructureObservable(bindVariableName, bindingExpression);\r\n    }\r\n    _makeBindVariableStructureObservable(bindVariableName, bindingExpression) {\r\n        const o = this._allBindVariables[bindVariableName];\r\n        const props = bindingExpression.split('.');\r\n        // Walk through property path and make subproperties observable\r\n        let propObj = o;\r\n        let propertyPath = bindVariableName;\r\n        for (let i = 0; i < props.length; i++) {\r\n            let lastProp = props[i];\r\n            propertyPath += `.${props[i]}`;\r\n            if (typeof propObj == \"undefined\")\r\n                return;\r\n            if (typeof propObj == 'object') {\r\n                if (!Array.isArray(propObj) && propertyPath.includes(\".\") && propObj[lastProp].bind)\r\n                    propObj[lastProp] = propObj[lastProp].bind(propObj);\r\n                // Do not observe function references\r\n                if (propObj[lastProp][\"bind\"])\r\n                    continue;\r\n                // Observe arrays and objects\r\n                if (!Array.isArray(propObj))\r\n                    this._makeObjectObservable(propObj, lastProp, bindVariableName, propertyPath);\r\n                else\r\n                    this._makeArrayObservable(propObj, lastProp, bindVariableName, propertyPath);\r\n            }\r\n            propObj = propObj[props[i]];\r\n        }\r\n    }\r\n    _callBindVariableBeforeChangedHook(obj, prop, newValue, oldValue) {\r\n        // Initial call / property not yet resolved -> dont execute hook\r\n        if (typeof oldValue == \"string\" && oldValue.startsWith(\"$\"))\r\n            return true;\r\n        const hookMethodName = `${prop}BeforeChanged`;\r\n        if (obj[hookMethodName]) {\r\n            const ret = obj[hookMethodName](newValue, oldValue);\r\n            if (typeof ret != \"undefined\" && ret == false)\r\n                return false;\r\n            return true;\r\n        }\r\n        return true;\r\n    }\r\n    _callBindVariableAfterChangedHook(obj, prop, newValue, oldValue) {\r\n        // Initial call / property not yet resolved -> dont execute hook\r\n        if (typeof oldValue == \"string\" && oldValue.startsWith(\"$\"))\r\n            return;\r\n        const hookMethodName = `${prop}AfterChanged`;\r\n        if (obj[hookMethodName])\r\n            obj[hookMethodName](newValue, oldValue);\r\n    }\r\n    _callBindVariableBeforePropertyChangedHook(obj, prop, subProp, newValue, oldValue) {\r\n        // Initial call / property not yet resolved -> dont execute hook\r\n        if (typeof oldValue == \"string\" && oldValue.startsWith(\"$\"))\r\n            return true;\r\n        const hookMethodName = `${prop}BeforePropertyChanged`;\r\n        if (obj[hookMethodName]) {\r\n            const ret = obj[hookMethodName](subProp, newValue, oldValue);\r\n            if (typeof ret != \"undefined\" && ret == false)\r\n                return false;\r\n            return true;\r\n        }\r\n        return true;\r\n    }\r\n    _callBindVariableAfterPropertyChangedHook(obj, prop, subProp, newValue, oldValue) {\r\n        // Initial call / property not yet resolved -> dont execute hook\r\n        if (typeof oldValue == \"string\" && oldValue.startsWith(\"$\"))\r\n            return;\r\n        const hookMethodName = `${prop}AfterPropertyChanged`;\r\n        if (obj[hookMethodName])\r\n            obj[hookMethodName](subProp, newValue, oldValue);\r\n    }\r\n    _makeObjectObservable(obj, observerProperty, componentProperty, propertyPath) {\r\n        let _value = obj[observerProperty];\r\n        const self = this;\r\n        // Register new observer if not already registered\r\n        this._registerNewObserver(obj, observerProperty, this, componentProperty, propertyPath);\r\n        // Replace property with property that calls all registered observers\r\n        if (!Object.getOwnPropertyDescriptor(obj, observerProperty).set && !Object.getOwnPropertyDescriptor(obj, observerProperty).get) {\r\n            Object.defineProperty(obj, observerProperty, {\r\n                get: function () { return _value; }.bind(this),\r\n                set: function (v) {\r\n                    const newValue = v;\r\n                    const oldValue = obj[observerProperty];\r\n                    self._applyValueAndNotifyObservers(obj, observerProperty, componentProperty, newValue, oldValue, false, () => _value = v);\r\n                }.bind(this),\r\n                enumerable: true,\r\n                configurable: true\r\n            });\r\n            // Adapt binding for methods in properties, so methods use this of surrounding object literal\r\n            // if (propertyPath.includes(\".\") && obj[observerProperty].bind)\r\n            //     obj[observerProperty] = obj[observerProperty].bind(obj);\r\n        }\r\n    }\r\n    _makeArrayObservable(arr, observerProperty, componentProperty, propertyPath) {\r\n        const self = this;\r\n        if (!this._registerNewObserver(arr, observerProperty, this, componentProperty, propertyPath)) {\r\n            arr._emit = function (index, items, deletedItems, action) {\r\n                // Use partial rendering only for change or delete operations with 1 element\r\n                if (items.length == 0)\r\n                    this.lastActionMethod = \"DELETE\";\r\n                else if (index == null)\r\n                    this.lastActionMethod = \"ADD\";\r\n                else if (items.length == 1)\r\n                    this.lastActionMethod = \"EDIT\";\r\n                this.lastActionIndex = index !== null && index !== void 0 ? index : this.length;\r\n                const newValue = items[items.length - 1];\r\n                const oldValue = deletedItems[deletedItems.length - 1];\r\n                ;\r\n                // Return last added, updated or deleted element\r\n                this.lastActionObject = newValue !== null && newValue !== void 0 ? newValue : oldValue;\r\n                self._applyValueAndNotifyObservers(this, observerProperty, componentProperty, newValue, oldValue, true, action);\r\n                // Reset action\r\n                this.lastActionMethod = null;\r\n                this.lastActionIndex = null;\r\n                this.lastActionObject = null;\r\n                this.lastActionPropertyPath = null;\r\n                return this;\r\n            };\r\n            arr.push = function (...items) {\r\n                arr._emit(null, items, [], () => Array.prototype.push.call(this, ...items));\r\n                return arr.length;\r\n            };\r\n            arr.splice = function (index, deleteCount, ...items) {\r\n                const deletedItems = this.slice(index, index + deleteCount);\r\n                if (deleteCount <= 1)\r\n                    arr._emit(index, items, deletedItems, () => Array.prototype.splice.call(this, index, deleteCount, ...items));\r\n                return deletedItems;\r\n            };\r\n            arr.edit = function (index, el) { return this.splice(index, 1, el); };\r\n            arr.delete = function (index) { return this.splice(index, 1); };\r\n        }\r\n    }\r\n    _applyValueAndNotifyObservers(obj, observerProperty, componentProperty, newValue, oldValue, arrayNotification, action) {\r\n        if (!this._callBindVariableBeforeChangedHook(obj, observerProperty, newValue, oldValue)\r\n            || !this._callBindVariableBeforePropertyChangedHook(self, componentProperty, observerProperty, newValue, oldValue))\r\n            return;\r\n        action();\r\n        obj._observers.get(observerProperty).forEach((componentDetails, component) => {\r\n            componentDetails.forEach((componentPropertyPaths, componentProperty) => {\r\n                componentPropertyPaths.forEach(componentPropertyPath => {\r\n                    // On arrays if length property is changed, array ist changed, so adapt\r\n                    // property path to match expressions depending on array instead of array.length property\r\n                    if (arrayNotification)\r\n                        componentPropertyPath = componentPropertyPath.replace(\".length\", \"\");\r\n                    let bindVariableValue = component[componentProperty];\r\n                    if (bindVariableValue) {\r\n                        if (!arrayNotification)\r\n                            bindVariableValue.lastActionMethod = \"SET\";\r\n                        bindVariableValue.lastActionPropertyPath = componentPropertyPath;\r\n                        component[componentProperty] = bindVariableValue;\r\n                        // bindVariableValue.lastActionMethod = null;\r\n                        // bindVariableValue.lastActionPropertyPath = null;\r\n                    }\r\n                });\r\n            });\r\n        });\r\n        this._callBindVariableAfterPropertyChangedHook(self, componentProperty, observerProperty, newValue, oldValue);\r\n        this._callBindVariableAfterChangedHook(obj, observerProperty, newValue, oldValue);\r\n    }\r\n    _registerNewObserver(obj, observerProperty, component, componentProperty, componentPropertyPath) {\r\n        let propertyAlreadyObserved = true;\r\n        if (!obj._observers)\r\n            obj._observers = new Map();\r\n        if (!obj._observers.has(observerProperty)) {\r\n            obj._observers.set(observerProperty, new Map());\r\n            propertyAlreadyObserved = false;\r\n        }\r\n        if (!obj._observers.get(observerProperty).has(component))\r\n            obj._observers.get(observerProperty).set(component, new Map());\r\n        if (!obj._observers.get(observerProperty).get(component).has(componentProperty))\r\n            obj._observers.get(observerProperty).get(component).set(componentProperty, []);\r\n        const objObserverList = obj._observers.get(observerProperty).get(component).get(componentProperty);\r\n        if (!objObserverList.includes(componentPropertyPath))\r\n            objObserverList.push(componentPropertyPath);\r\n        return propertyAlreadyObserved;\r\n    }\r\n    _calculateBindings(htmlFunction, bindVariableNames) {\r\n        for (let bindVariableName of bindVariableNames) {\r\n            const regexp = new RegExp(`(${bindVariableName})((\\\\.[\\\\w]+)+)`, 'g');\r\n            if (!this._allBindExpressions[bindVariableName])\r\n                this._allBindExpressions[bindVariableName] = [];\r\n            for (const [, , expression] of htmlFunction.matchAll(regexp)) {\r\n                const expr = expression.substring(1);\r\n                if (!this._allBindExpressions[bindVariableName].includes(expr))\r\n                    this._allBindExpressions[bindVariableName].push(expr);\r\n            }\r\n            this._makeBindVariableObservable(bindVariableName);\r\n        }\r\n    }\r\n    _renderFull(parentElement, htmlFunction, locals) {\r\n        const [elements, bindVariables, bindVariableNames] = this._parseHTML(htmlFunction, locals);\r\n        const lastExistingElement = parentElement.childNodes.length;\r\n        while (elements.length > 0) // Elements are extracted from source at appendChild, therefore always first element\r\n            parentElement.appendChild(elements[0]);\r\n        // Incrementally process only those elements recursively that have not been processed via\r\n        // previous renderList or renderContent method within the same render method, so that the\r\n        // same elements are not processed multiple times and added to the observables data structure.\r\n        for (let index = lastExistingElement; index < parentElement.childNodes.length; index++)\r\n            this._processElementBinding(parentElement.childNodes[index], bindVariables, bindVariableNames);\r\n    }\r\n    _removeObserversForBindVariable(bindVariableToDelete) {\r\n        // Remove observer expressions\r\n        if (this._observersForBindVariable.has(bindVariableToDelete))\r\n            for (const [comp] of this._observersForBindVariable.get(bindVariableToDelete)) {\r\n                for (const [attr, expr] of this._observerExpressions.get(comp))\r\n                    if (expr.bindVariableNames.includes(bindVariableToDelete))\r\n                        this._observerExpressions.get(comp).delete(attr);\r\n                if (this._observerExpressions.get(comp).size == 0)\r\n                    this._observerExpressions.delete(comp);\r\n            }\r\n        // Remove observers for bind variable\r\n        this._observersForBindVariable.delete(bindVariableToDelete);\r\n        // Remove bind variable\r\n        delete this._allBindVariables[bindVariableToDelete];\r\n        // Remove all bind expressions for bind variable\r\n        delete this._allBindExpressions[bindVariableToDelete];\r\n    }\r\n    _calculateArrayChange(value, oldValue) {\r\n        if (value.length > oldValue.length)\r\n            value.lastActionMethod = \"ADD\";\r\n        else if (value.length < oldValue.length)\r\n            value.lastActionMethod = \"DELETE\";\r\n        else\r\n            value.lastActionMethod = \"EDIT\";\r\n        // Compare arrays\r\n        const maxArray = value.lastActionMethod == \"DELETE\" ? oldValue : value;\r\n        for (let i = 0; i < maxArray.length; i++)\r\n            if (value[i] != oldValue[i]) {\r\n                value.lastActionIndex = i;\r\n                value.lastActionObject = maxArray[i];\r\n                // Return calculated action details\r\n                return value;\r\n            }\r\n        // No update action required because arrays are identical\r\n        value.lastActionMethod = \"NONE\";\r\n        return value;\r\n    }\r\n    _renderUpdate(listProp, value, oldValue) {\r\n        // If oldValue or initial value is of type array and this component\r\n        // is a list component, do partial rendering (otherwise no action is required\r\n        // because if no list is involved, no new html tags have to be created and\r\n        // simple property update and existing dom element attribute update are enough)\r\n        if (Array.isArray(oldValue) && this._lists.size > 0) {\r\n            let elementsBeforeShift = 0;\r\n            // Update all lists depending on changed property, if property is used in rendered list\r\n            if (this._lists.has(listProp))\r\n                for (const list of this._lists.get(listProp))\r\n                    elementsBeforeShift = this._renderListUpdate(list, value, elementsBeforeShift);\r\n        }\r\n    }\r\n    _renderListUpdate(listData, value, elementsBeforeShift) {\r\n        // If rendered list does not map directly to original array because of intermediate mapping, filtering etc.\r\n        // action properties such as value.lastActionIndex are not available or cannot be used and have to be\r\n        // calculated by applying comparison between elements of old and new mapped array\r\n        if (listData.listDerived) {\r\n            const lastActionIndexBeforeMapping = value.lastActionIndex;\r\n            // Apply mapping function\r\n            value = listData.listFunction();\r\n            // Caluclate array changes if not complete array reassignment was triggered\r\n            if (typeof lastActionIndexBeforeMapping != \"undefined\")\r\n                value = this._calculateArrayChange(value, listData.listCurrentData);\r\n        }\r\n        // Change in list does not regard rendered content (e.g. no change in already rendered items)?\r\n        if (value.lastActionMethod == \"NONE\")\r\n            return elementsBeforeShift;\r\n        // Partial rendering of added, updated or deleted element\r\n        if (typeof value.lastActionIndex != \"undefined\") {\r\n            this._renderListElementUpdate(listData, value);\r\n            HofLogging.logRenderUpdate(this, listData.listProperty, value, listData.listDerived\r\n                ? \"Partial (search) rerender\"\r\n                : \"Partial (index) rerender\");\r\n        }\r\n        else { // Full rerendering, because Array was not modified by adding, deleting or updating one item, but by reassigning a new array  \r\n            // Remove all old elements\r\n            value.lastActionMethod = \"DELETE\";\r\n            for (let i = 0; i < listData.listCurrentData.length; i++) {\r\n                value.lastActionIndex = 0;\r\n                value.lastActionObject = listData.listCurrentData[i];\r\n                this._renderListElementUpdate(listData, value);\r\n            }\r\n            // Insert new array elements\r\n            value.lastActionMethod = \"ADD\";\r\n            for (let i = 0; i < value.length; i++) {\r\n                value.lastActionIndex = i;\r\n                this._renderListElementUpdate(listData, value);\r\n            }\r\n            // Reset, so next list has some data\r\n            value.lastActionMethod = undefined;\r\n            value.lastActionIndex = undefined;\r\n            value.lastActionObject = undefined;\r\n            HofLogging.logRenderUpdate(this, listData.listProperty, value, \"Full rerender\");\r\n        }\r\n        // Save copy to allow comparison with old value on next update for mapped arrays and to support full rendering\r\n        // on assignment of a new array instead of adding, editing or deleting one element of array\r\n        listData.listCurrentData = [...value];\r\n        // Update list parent element depending on list element size\r\n        return this._renderListParentUpdate(listData, elementsBeforeShift);\r\n    }\r\n    _renderListParentUpdate(listData, elementsBeforeShift) {\r\n        const oldRootElementCount = this._root.childNodes.length;\r\n        // Only change rendering if parent element should be rendered based on list size\r\n        if (!listData.listParentElementRenderOnEmptyList) {\r\n            // If list is empty, remove parent element, because no empty ul-elements etc are allowed\r\n            // and if list is not empty but parent element not rendered, add it\r\n            listData.listParentElementIndex += elementsBeforeShift;\r\n            if (listData.listParentElement.childNodes.length == 0)\r\n                this._root.removeChild(listData.listParentElement);\r\n            else {\r\n                let listNodeIsInRoot = false;\r\n                this._root.childNodes.forEach(node => { if (node == listData.listParentElement)\r\n                    listNodeIsInRoot = true; });\r\n                if (!listNodeIsInRoot) {\r\n                    if (this._root.childNodes[listData.listParentElementIndex])\r\n                        this._root.insertBefore(listData.listParentElement, this._root.childNodes[listData.listParentElementIndex]);\r\n                    else\r\n                        this._root.appendChild(listData.listParentElement);\r\n                }\r\n            }\r\n        }\r\n        return this._root.childNodes.length - oldRootElementCount + elementsBeforeShift;\r\n    }\r\n    _renderListElementUpdate(listData, value) {\r\n        // Calculate list element index based on last action index (array index) and shift on other lists rendered above this list\r\n        const elementChangeIndex = value.lastActionIndex * listData.listElementTemplateSize;\r\n        // Remove node\r\n        if (value.lastActionMethod == \"DELETE\") {\r\n            this._removeObserversForBindVariable(value.lastActionObject._observableUniqueName);\r\n            // Remove all nodes of item at index\r\n            for (let i = 0; i < listData.listElementTemplateSize; i++)\r\n                listData.listParentElement.childNodes[elementChangeIndex].remove();\r\n        }\r\n        else {\r\n            const locals = {};\r\n            locals[listData.listItemVariable] = value[value.lastActionIndex];\r\n            locals[listData.listItemVariable]._observableUniqueName = listData.listItemVariable + \"__it\" + (this._renderIteration + 1);\r\n            if (listData.listIndexVariable)\r\n                locals[listData.listIndexVariable] = value.lastActionIndex;\r\n            if (listData.listItemUpdatedVariable)\r\n                locals[listData.listItemUpdatedVariable] = true;\r\n            // Parse new html for added or updated content\r\n            const [elements, bindVariables, bindVariableNames] = this._parseHTML(listData.listElementTemplateFunction, locals);\r\n            for (let i = 0; i < listData.listElementTemplateSize; i++) {\r\n                // Add or replace html (elements are extracted from source at appendChild, therefore always first element)\r\n                if (value.lastActionMethod == \"ADD\") {\r\n                    if (listData.listParentElement.childNodes[value.lastActionIndex])\r\n                        listData.listParentElement.insertBefore(elements[0], listData.listParentElement.childNodes[elementChangeIndex + i]);\r\n                    else\r\n                        listData.listParentElement.appendChild(elements[0]);\r\n                    this._processElementBinding(listData.listParentElement.childNodes[elementChangeIndex + i], bindVariables, bindVariableNames);\r\n                }\r\n                else if (value.lastActionMethod == \"EDIT\") {\r\n                    listData.listParentElement.replaceChild(elements[0], listData.listParentElement.childNodes[elementChangeIndex + i]);\r\n                    this._processElementBinding(listData.listParentElement.childNodes[elementChangeIndex + i], bindVariables, bindVariableNames);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    _makeDerivedVariablesObservable(path, variableName, variableBody, html, functionWrappedGetter) {\r\n        // Make derived bind variables observable by adding referenced bind variables to template\r\n        let referencedBindVariableNames = \"/* references: \";\r\n        for (const [, referencedBindVariableName] of variableBody.matchAll(this.REFERENCED_BIND_VARIABLE_NAMES_REGEX))\r\n            referencedBindVariableNames += `${path}.${referencedBindVariableName.replace(\"this.\", \"\")}; `;\r\n        referencedBindVariableNames += \"*/\";\r\n        return html.replaceAll(new RegExp(`([^\\\\w])${path}\\\\.${variableName}([^\\\\w])`, \"g\"), `$1(${path}${functionWrappedGetter ? \"()\" : \"\"}.${variableName} ${referencedBindVariableNames} )$2`);\r\n    }\r\n    _calculateUniqueElementAndVariableName(name, renderIteration) {\r\n        return name + \"__it\" + renderIteration;\r\n    }\r\n    _calculateTemplateAndBindVariableNames(html, props, locals) {\r\n        this._renderIteration++;\r\n        // Determine all binding variables\r\n        const bindVariables = Object.keys(props);\r\n        // Add additional local variables to binding\r\n        if (locals) {\r\n            for (let [variableName, variableValue] of Object.entries(locals)) {\r\n                const uniqueBindVariableName = variableName + \"__it\" + this._renderIteration;\r\n                props[uniqueBindVariableName] = variableValue;\r\n                bindVariables.push(uniqueBindVariableName);\r\n                // Replace variables with unique name (needs be done incrementally instead of\r\n                // global matching regex, because global matching regex selects to much\r\n                // with one pattern and as a consequence would pass on some matches)\r\n                let replacedHtml = html;\r\n                do {\r\n                    html = replacedHtml;\r\n                    replacedHtml = html.replace(new RegExp(`([{][^{}]*[^\\\\w]|[{])${variableName}([^\\\\w])`), `$1${uniqueBindVariableName}$2`);\r\n                } while (replacedHtml.length != html.length);\r\n            }\r\n        }\r\n        // Make derived global bind variables observable\r\n        const regexp = new RegExp('this((\\\\.\\\\w+)*)\\\\.(\\\\w+)[^\\\\w(]', 'g');\r\n        let prop = null;\r\n        for (const [, path, , expr] of html.matchAll(regexp)) {\r\n            let propObj = props;\r\n            if (path) {\r\n                const properties = path.split(\".\");\r\n                for (prop of properties)\r\n                    if (prop != \"\")\r\n                        propObj = propObj[prop] || this._derivedProperties[prop].call(this);\r\n            }\r\n            if (this._derivedProperties[prop]) // Derived property of component (function wrapped to support propertyReferences)?\r\n                html = this._makeDerivedVariablesObservable(`this${path}`, expr, this._derivedProperties[prop].toString(), html, false);\r\n            else if (path && Object.getOwnPropertyDescriptor(propObj, expr).get && !Object.getOwnPropertyDescriptor(propObj, expr).set) // Derived component of nested/store object property (not wrapped)?\r\n                html = this._makeDerivedVariablesObservable(`this${path}`, expr, Object.getOwnPropertyDescriptor(propObj, expr).get.toString(), html, false);\r\n        }\r\n        // Encode html tags within expressions because otherwise the parser parses them as separate elements\r\n        // (e.g. <div>() => `${this.persons.length > 0 ? \"<h2>Filtered list</h2>\" : \"\"}</div> would be parsed as div and h2 tags)\r\n        html = this._escapeTagsInExpressions(html);\r\n        return [html, bindVariables];\r\n    }\r\n    _escapeTagsInExpressions(html) {\r\n        const stringTokens = [\"\\\"\", \"'\", \"`\"];\r\n        for (let stringToken of stringTokens) {\r\n            let stringExpressions = html.match(new RegExp(`${stringToken}[^${stringToken}]+${stringToken}`, \"g\"));\r\n            if (stringExpressions)\r\n                for (let match of stringExpressions)\r\n                    if (match.includes(\"<\"))\r\n                        html = html.replace(match, match.replaceAll(\"<\", \"&lt;\"));\r\n        }\r\n        return html;\r\n    }\r\n    _processElementBinding(element, bindVariables, bindVariableNames) {\r\n        // Support databinding expressions in attributes (regular DOM elements)\r\n        if (\"attributes\" in element)\r\n            Array.from(element.attributes).forEach((attr) => {\r\n                if (attr.nodeValue.includes(\"${\"))\r\n                    this._processBindingExpression(element, bindVariables, bindVariableNames, attr.nodeName, attr.nodeValue);\r\n            });\r\n        // Support databinding expressions within tags (TextNodes)\r\n        if (\"data\" in element) {\r\n            if (element.data.includes(\"${\"))\r\n                this._processTextNodeBinding(element, bindVariables, bindVariableNames, element.data);\r\n        }\r\n        // Edit child elements recursively\r\n        if (\"childNodes\" in element)\r\n            for (const childElement of Array.from(element.childNodes))\r\n                this._processElementBinding(childElement, bindVariables, bindVariableNames);\r\n        // Render elements with render support      \r\n        if (element instanceof HofHtmlElement)\r\n            element.render();\r\n    }\r\n    _processTextNodeBinding(textNode, bindVariables, bindVariableNames, expr) {\r\n        // Replace text nodes with span elements to support rendering of html content by expressions\r\n        if (textNode.parentNode) {\r\n            var replacementNode = document.createElement('span');\r\n            textNode.parentNode.insertBefore(replacementNode, textNode);\r\n            textNode.parentNode.removeChild(textNode);\r\n            this._processBindingExpression(replacementNode, bindVariables, bindVariableNames, \"innerHTML\", expr);\r\n        }\r\n        else\r\n            this._processBindingExpression(textNode, bindVariables, bindVariableNames, \"data\", textNode.data);\r\n    }\r\n    _processBindingExpression(element, bindVariables, bindVariableNames, attr, expr) {\r\n        // Build callable expression to (re)calculate value of attribute based on depending binding variables  \r\n        const attributeExpression = this._buildCallableExpression(attr, expr, bindVariableNames);\r\n        // Save attribute expression for later execution on bind variable changes\r\n        if (!this._observerExpressions.has(element))\r\n            this._observerExpressions.set(element, new Map());\r\n        this._observerExpressions.get(element).set(attr, attributeExpression);\r\n        // Rebind this of subproperties to parent property\r\n        for (let bindVariableName of attributeExpression.bindVariableNames)\r\n            if (bindVariables[bindVariableName].bind)\r\n                bindVariables[bindVariableName] = bindVariables[bindVariableName].bind(this); // pass this from parent to child on callbacks that are passed down\r\n        // Determine current values\r\n        const bindVariableValues = this._getBindVariableValues(attributeExpression.bindVariableNames);\r\n        // Get current value of element attribute by evaluating expression\r\n        let value = attributeExpression.execute(...bindVariableValues);\r\n        if (value[\"bind\"]) // If value is function, then bind\r\n            value = value.bind(this);\r\n        // Set value\r\n        element[attr] = value;\r\n        // Register combination of element and attribute as observer for each bind variable name\r\n        if (value != null && !value[\"bind\"]) // Do not observe functions\r\n            this._registerElementAttributeAsObserverForBindVariables(element, attr, bindVariables, attributeExpression.bindVariableNames);\r\n    }\r\n    _buildCallableExpression(attr, expr, bindVariableNames) {\r\n        // If expression is the only expression, do not interpret it as string,\r\n        // but evaluate directly so that references to functions can be assigned to properties\r\n        if (attr == \"data\" || expr.lastIndexOf(\"${\") > 0 || expr.lastIndexOf(\"}\") < expr.length - 1)\r\n            expr = \"`\" + expr + \"`\";\r\n        else\r\n            expr = expr.replaceAll(\"${\", \"\").replaceAll(\"}\", \"\");\r\n        let referencedBindVariables = [];\r\n        for (const bindVariableName of bindVariableNames) {\r\n            if (expr.includes(bindVariableName))\r\n                referencedBindVariables.push(bindVariableName);\r\n        }\r\n        // Currently, in addition to the local variables (additional variables passed to renderContent/renderList),\r\n        // the WebComponent's properties are also passed as local variables to the WebComponent's attribute function,\r\n        // which is not really necessary, but facilitates the generic handling\r\n        return new AttributeExpression(new Function(...referencedBindVariables, \"return \" + expr).bind(this), referencedBindVariables, expr);\r\n    }\r\n    _registerElementAttributeAsObserverForBindVariables(element, attr, bindVariables, referencedBindVariableNames) {\r\n        // Add combination of element and attribute to observer structure\r\n        for (let bindVariableName of referencedBindVariableNames) {\r\n            if (!this._observersForBindVariable.has(bindVariableName))\r\n                this._observersForBindVariable.set(bindVariableName, new Map());\r\n            const variableObservable = this._observersForBindVariable.get(bindVariableName);\r\n            if (!variableObservable.has(element))\r\n                variableObservable.set(element, []);\r\n            if (bindVariables[bindVariableName].bind)\r\n                bindVariables[bindVariableName] = bindVariables[bindVariableName].bind(this); // pass this from parent to child on callbacks that are passed down\r\n            variableObservable.get(element).push(attr);\r\n        }\r\n    }\r\n    _getBindVariableValues(bindVariableNames) {\r\n        let result = [];\r\n        for (const b of bindVariableNames)\r\n            result.push(this._allBindVariables[b]);\r\n        return result;\r\n    }\r\n    _updatePropertyObservers(bindVariable) {\r\n        const [bindVariableName, bindVariableValue] = bindVariable;\r\n        // Render partially only if element has already been created.\r\n        // (Setters should also be able to be called before component\r\n        // has been created for the first time, which is why state setters\r\n        // only change state here, but have no effect on UI yet).\r\n        if (this._observersForBindVariable.has(bindVariableName)) {\r\n            for (const [element, attrs] of this._observersForBindVariable.get(bindVariableName).entries()) {\r\n                // Remove removed components from bindings\r\n                if (typeof this._observerExpressions.get(element) == \"undefined\") {\r\n                    this._observersForBindVariable.get(bindVariableName).delete(element);\r\n                    continue;\r\n                }\r\n                ;\r\n                for (const attrName of attrs) {\r\n                    const attrExpr = this._observerExpressions.get(element).get(attrName);\r\n                    if (!bindVariableValue.lastActionPropertyPath || attrExpr.template.includes(bindVariableValue.lastActionPropertyPath)) {\r\n                        // Reevaluate binding expression\r\n                        const bindVariableValues = this._getBindVariableValues(attrExpr.bindVariableNames);\r\n                        const newValue = attrExpr.execute(...bindVariableValues);\r\n                        // Always propagate changes in properties to all observer elements and\r\n                        // propagate changes in subproperties only if subproperty is included in binding expression / template\r\n                        // (e.g. if data.selectedPerson.name is changed, only attributes with bindings to data, data.selectedPerson\r\n                        // and data.selectedPerson.name, but e.g. not on data.selectedPerson.age).\r\n                        if (typeof newValue.lastActionIndex != \"undefined\" || !bindVariableValue.lastActionPropertyPath || attrExpr.template && attrExpr.template.includes(bindVariableValue.lastActionPropertyPath)) {\r\n                            if (element[attrName] != newValue) {\r\n                                element[attrName] = newValue;\r\n                                // Log rerendering of non HofHtmlElements because they include no detailed logging like HofHtmlElements do\r\n                                if (!(element instanceof HofHtmlElement))\r\n                                    HofLogging.logRenderUpdate(element, attrName, newValue, \"Full rerender\");\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nexport function html(htmlRenderFunc) { return htmlRenderFunc; }\r\nexport function htmlForList(list, htmlRenderFunc, parentElement = \"div\", renderParentElementOnEmptyList = false) {\r\n    return [list, htmlRenderFunc, parentElement, renderParentElementOnEmptyList];\r\n}\r\nclass HofLogging {\r\n    static setDebugging(debugging) {\r\n        HofLogging.logPropertyUpdates = debugging;\r\n        HofLogging.logInitialRenderings = debugging;\r\n        HofLogging.logRenderUpdates = debugging;\r\n    }\r\n    static logPropertyUpdate(element, name, value) {\r\n        // Dont log parent property changes since only child props are really updated because of partial rendering\r\n        // and these are additionally logged\r\n        if (HofLogging.logPropertyUpdates && !value.lastActionPropertyPath)\r\n            HofLogging.logElementActivity(element, name, value, \"Update\");\r\n    }\r\n    static logInitialRendering(element, renderIteration, properties) {\r\n        if (HofLogging.logInitialRenderings && renderIteration == 0)\r\n            for (const prop of Object.keys(properties))\r\n                HofLogging.logElementActivity(element, prop, properties[prop], \"Initial render\");\r\n    }\r\n    static logRenderUpdate(element, name, value, mode) {\r\n        if (HofLogging.logRenderUpdates)\r\n            HofLogging.logElementActivity(element, name, value, mode);\r\n    }\r\n    static logElementActivity(element, name, value, mode) {\r\n        var _a, _b;\r\n        // Filter out function references on first rendering because they are not observed\r\n        if (value[\"bind\"])\r\n            return;\r\n        // No update was required because rendered part of array did not change\r\n        if (value.lastActionMethod == \"NONE\")\r\n            return;\r\n        console.log(`[${HofLogging._calculateElementDisplayName(element)}]: ${mode} of property ${name}: `\r\n            + `${(_a = value.lastActionMethod) !== null && _a !== void 0 ? _a : \"SET\"} ${JSON.stringify((_b = value.lastActionObject) !== null && _b !== void 0 ? _b : value)}`);\r\n    }\r\n    static _calculateElementDisplayName(element) {\r\n        var _a;\r\n        let elementName = (_a = element.nodeName) !== null && _a !== void 0 ? _a : \"TEXT\";\r\n        if (element instanceof HofHtmlElement)\r\n            return elementName;\r\n        // Look for HofHtmlElements above this HofHtmlElement\r\n        for (let node = element; node; node = node.parentNode) {\r\n            if (node.toString() === \"[object ShadowRoot]\" && node[\"host\"] instanceof HofHtmlElement)\r\n                elementName = node[\"host\"].nodeName + \">\" + elementName; // HofHtmlElement that contains this HofHtmlElement was found\r\n        }\r\n        return elementName;\r\n    }\r\n}\r\nHofLogging.setDebugging(false);\r\n", "import { HofHtmlElement } from \"@hofjs/hofjs/lib/esm/hof\";\r\n\r\ninterface RoutesConfig {\r\n    [routeName: string]: RouteConfig\r\n}\r\n\r\ninterface RouteConfig {\r\n    url: string;\r\n    component: new() => HofHtmlElement;\r\n    params: Object;\r\n    redirect: string;\r\n    aliases: string[];\r\n}\r\n\r\ninterface Routes {\r\n    [routeName: string]: Route\r\n}\r\n\r\ninterface Route extends RouteConfig {\r\n    urlRegex: RegExp,\r\n    aliasesRegexes: RegExp[];\r\n    renderElementParent: ShadowRoot;\r\n    renderElementId: string;\r\n}\r\n\r\ninterface RouteInfo {\r\n    url: string;\r\n    query: string;\r\n    params: Object;\r\n}\r\n\r\ninterface UrlParams {\r\n    [routeName: string]: string\r\n}\r\n\r\nexport class HofRouter {\r\n    static initialized: boolean = false;\r\n    static routes: Routes = {};\r\n    static defaultRoute: Route = null;\r\n    static current: RouteInfo = null;\r\n\r\n    static _setup() {\r\n        HofRouter.initialized = true;\r\n        window.onload = () => {                 \r\n            HofRouter.processRoute(document.location.href, true, false);\r\n\r\n            document.body.addEventListener('click', function(e: MouseEvent) {\r\n                const el = e[\"path\"][0];\r\n                if (el.nodeName == 'A') {\r\n                    e.preventDefault();\r\n                    HofRouter.processRoute(el.attributes[0].nodeValue);\r\n                }\r\n            });\r\n        }\r\n        window.onpopstate = (event: PopStateEvent) => { HofRouter.processRoute(event.state.url, false, false);}\r\n    }\r\n\r\n    static _buildRoute(renderElementParent: ShadowRoot, renderElementId: string, config: RouteConfig): Route {\r\n        return {\r\n            url: config.url,\r\n            urlRegex: calculatePathExpression(config.url), // Support shortcut parameter syntax :param\r\n            component: config.component,\r\n            params: config.params,\r\n            redirect: config.redirect,\r\n            aliases: config.aliases,\r\n            aliasesRegexes: config.aliases?.map(alias => calculatePathExpression(alias)),\r\n            renderElementParent, renderElementId\r\n        };\r\n\r\n        function calculatePathExpression(path: string): RegExp {\r\n            if (path == \"*\")\r\n                return new RegExp(\"^.*$\");\r\n\r\n            return new RegExp(\"^\" + path.replace(/:([a-zA-Z0-9]+)/, \"(?<$1>[\\\\w-]+)\") + \"(\\\\?(?<$routeQuery>.*))?$\");\r\n        }\r\n    }\r\n\r\n    static configRoutes(renderElementParent: ShadowRoot, renderElementId: string, routeEntries: RoutesConfig) {\r\n        if (!HofRouter.initialized) HofRouter._setup();\r\n\r\n        for (const [name, config] of Object.entries(routeEntries)) {\r\n            const route = HofRouter._buildRoute(renderElementParent, renderElementId, config);\r\n\r\n            if (config.url == \"*\") HofRouter.defaultRoute = route;\r\n            else HofRouter.routes[name] = route;\r\n        }\r\n    }\r\n\r\n    static _findCurrentView(mountElement: HTMLElement): HofHtmlElement {\r\n        for (const child of Array.from(mountElement.children))\r\n            if (child[\"style\"] && child[\"style\"].display != 'none')\r\n                return child as HofHtmlElement;\r\n\r\n        return null;\r\n    }\r\n\r\n    static _findNextView(mountElement: HTMLElement, route: Route): HofHtmlElement {\r\n        for (const child of Array.from(mountElement.children))\r\n            if (child instanceof HofHtmlElement && child.getAttribute(\"router-url\") == route.url)\r\n                return child;\r\n\r\n        return null;\r\n    }\r\n\r\n    static _updateView(view: HofHtmlElement, route: Route, urlParams: UrlParams) {\r\n        // Initialize component with configured parameters\r\n        for (const param in route.params)\r\n            view[param] = route.params[param];\r\n\r\n        // Build injectable route object\r\n        const routeInfo = { url: route.url, params: {}, query: \"\" };\r\n        for (const param in urlParams) {                             \r\n            if (param == \"$routeQuery\") {\r\n                if (typeof urlParams[param] != 'undefined') {\r\n                    for (const paramExpr of urlParams[param].split(\"&\")) {\r\n                        const paramNameAndValue = paramExpr.split(\"=\");\r\n                        if (paramNameAndValue.length == 2)\r\n                        routeInfo.params[paramNameAndValue[0]] = paramNameAndValue[1];\r\n                    }\r\n\r\n                    routeInfo.query = urlParams[param];\r\n                }\r\n            }\r\n            else\r\n                view[param] = urlParams[param];\r\n        }\r\n\r\n        HofRouter.current = routeInfo;\r\n         \r\n        view.setAttribute(\"router-url\", route.url);\r\n    }\r\n\r\n    static _loadView(mountElement: HTMLElement, route: Route, urlParams: UrlParams) {\r\n        const view = new route.component();\r\n        \r\n        // View should be initially hidden\r\n        view.style.display = 'none';\r\n\r\n        HofRouter._updateView(view as HofHtmlElement, route, urlParams);\r\n\r\n        mountElement.appendChild(view);\r\n        \r\n        view.render();\r\n\r\n        return view;\r\n    }\r\n\r\n    static _callBeforeRoutingHook(view: HofHtmlElement, nextUrl: string, currentUrl: string) {\r\n        if (view != null && view[\"beforeRouting\"]) {\r\n            const ret = view[\"beforeRouting\"](nextUrl, currentUrl);\r\n            if (typeof ret != \"undefined\" && ret == false)\r\n                return false; \r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    static _callAfterRoutingHook(view: HofHtmlElement, nextUrl: string, currentUrl: string) {\r\n        if (view != null && view[\"afterRouting\"])\r\n            view[\"afterRouting\"](nextUrl, currentUrl);\r\n    }\r\n\r\n    static _resolveRouterUrl(url: string) {\r\n        // Sample: <a href=\"router:pageDetails(id=1, param1=Hello, param2=World)\">Details 3</a>\r\n\r\n        const paramsStartIndex = url.indexOf(\"(\");\r\n        const paramsEndIndex = url.indexOf(\")\");\r\n        const routeName = paramsStartIndex == -1 ? url.substring(7) : url.substring(7, paramsStartIndex);\r\n        const parametersExpr = paramsStartIndex == -1 ? \"\" : url.substring(paramsStartIndex+1, paramsEndIndex);\r\n\r\n        // Resolve integrated router functions\r\n        if (routeName == \"back\") { HofRouter.back(); return null; }\r\n        else if (routeName == \"forward\") { HofRouter.forward(); return null; }\r\n        else if (routeName == \"go\") { HofRouter.go(parseInt(parametersExpr)); return null; }\r\n        else if (routeName == \"push\") { HofRouter.push(parametersExpr); return null; }\r\n        else if (routeName == \"replace\") { HofRouter.replace(parametersExpr); return null; }\r\n\r\n        let resolvedUrl = HofRouter.routes[routeName].url;\r\n        let resolvedUrlQuery = \"?\";\r\n\r\n        if (parametersExpr)\r\n            for (const param of parametersExpr.split(\",\")) {\r\n                let [name, value] = param.trim().split(\"=\");\r\n                \r\n                if (resolvedUrl.includes(`:${name}`))\r\n                    resolvedUrl = resolvedUrl.replace(`:${name}`, value);\r\n                else\r\n                    resolvedUrlQuery += `${name}=${value}&`;\r\n            }\r\n        resolvedUrlQuery = resolvedUrlQuery.substring(0, resolvedUrlQuery.length-1);\r\n        resolvedUrl += resolvedUrlQuery;\r\n\r\n        return resolvedUrl;\r\n    }\r\n\r\n    static _matchRoute(nextUrl: string, route: Route, updateHistory: boolean, addMode: boolean) {\r\n        if (nextUrl.startsWith(\"router:\")) {\r\n            nextUrl = HofRouter._resolveRouterUrl(nextUrl);\r\n            \r\n            // Router action already processed, i.e. no nextUrl\r\n            if (nextUrl == null) return true;\r\n        }\r\n\r\n        const match = route.urlRegex.exec(nextUrl)\r\n            ?? route.aliasesRegexes?.map(alias => alias.exec(nextUrl)).find(alias => alias != null);\r\n\r\n        if (match != null) {\r\n            if (route.redirect) return true;\r\n\r\n            const mountElement = route.renderElementParent.getElementById(route.renderElementId);\r\n            const currentViewComponent = HofRouter._findCurrentView(mountElement);\r\n            const currentUrl = currentViewComponent?.getAttribute(\"router-url\");\r\n            const urlParams = match.groups;\r\n            const nextViewComponent = HofRouter._findNextView(mountElement, route)\r\n                ?? HofRouter._loadView(mountElement, route, urlParams);\r\n\r\n            HofRouter._callBeforeRoutingHook(currentViewComponent, nextUrl, currentUrl);\r\n            HofRouter._callBeforeRoutingHook(nextViewComponent, nextUrl, currentUrl);\r\n\r\n            if (currentViewComponent)\r\n                currentViewComponent.style.display = 'none';\r\n            nextViewComponent.style.display = '';\r\n\r\n            HofRouter._updateView(nextViewComponent, route, urlParams);\r\n\r\n            if (updateHistory) {\r\n                if (addMode) history.pushState({ url: nextUrl }, \"\", nextUrl);                       \r\n                else history.replaceState({ url: nextUrl }, \"\", nextUrl);                            \r\n            }\r\n\r\n            HofRouter._callAfterRoutingHook(currentViewComponent, nextUrl, currentUrl);\r\n            HofRouter._callAfterRoutingHook(nextViewComponent, nextUrl, currentUrl);\r\n            \r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    static processRoute(nextUrl: string, updateHistory: boolean = true, addMode: boolean = true) {\r\n        // Try to match against regular routes\r\n        for (const route of Object.values(HofRouter.routes)) {\r\n            if (HofRouter._matchRoute(nextUrl, route, updateHistory, addMode)) {\r\n                if (route.redirect)\r\n                    HofRouter.processRoute(route.redirect, updateHistory, addMode);\r\n\r\n                return;\r\n            }\r\n        }\r\n\r\n        // Try to match against default route\r\n        if (HofRouter.defaultRoute && HofRouter._matchRoute(nextUrl, HofRouter.defaultRoute, updateHistory, addMode)) {\r\n            if (HofRouter.defaultRoute.redirect)\r\n                HofRouter.processRoute(HofRouter.defaultRoute.redirect, updateHistory, addMode);\r\n\r\n            return;\r\n        }\r\n\r\n        // No matching route found\r\n        throw Error(`No matching route definition to resolve url ${nextUrl}!`);\r\n    }\r\n\r\n    static back() { history.back(); }\r\n    static forward() { history.forward(); }\r\n    static go(delta: number) { history.go(delta); }\r\n    static push(url: string) { HofRouter.processRoute(url, true, true); }\r\n    static replace(url: string) { HofRouter.processRoute(url, true, false); }\r\n}", "// File, which is used to import library via regular import mechanism\r\n// but then adding imported entities to the window object\r\n// so that even without modules the JavaScript code will be executed\r\n// and can be used directly in a web application (this file is used\r\n// by esbuild to create nomodule version of this library)\r\n\r\n// Import elements of library\r\nimport { HofRouter } from '../hofrouter'\r\n\r\n// Make elements of library accessible on the window object\r\n(window as any).HofRouter = HofRouter;"],
  "mappings": "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",
  "names": []
}
