{
  "version": 3,
  "sources": ["../../src/hof.ts", "../../src/esbuild-wrapper/hof.esbuild.ts"],
  "sourcesContent": ["// https://github.com/prateek3255/typescript-react-demo-library\r\n\r\n// Adapt bind to preserve function body instead of returning [native code] if function is bound which is\r\n// important because _makeDerivedVariablesObservable requires function body to setup observability\r\n(function () {\r\n    const originalBind = Function.prototype.bind;\r\n\r\n    // Only adapt if extension has not already been applied\r\n    if (originalBind.toString().includes(\"[native code]\"))\r\n        Function.prototype.bind = function () {\r\n            const result = originalBind.apply(this, arguments);\r\n            result.toString = () => this.toString();\r\n\r\n            return result;\r\n        }\r\n}());\r\n\r\n// Shim replaceAll if not supported on browser by using a simplified implementation\r\n// that provides all required functionality for this framework\r\n(function () {\r\n    if (!String.prototype.replaceAll) {\r\n        String.prototype.replaceAll = function (find: any, replace: any): string {\r\n            let s = '', index, next;\r\n            while (~(next = this.indexOf(find, index))) {\r\n                s += this.substring(index, next) + replace;\r\n                index = next + find.length;\r\n            }\r\n            return s + this.substring(index);\r\n        };\r\n    }\r\n}());\r\n\r\ninterface PropertyMap {\r\n    [propertyName: string]: Object & Partial<{ bind(thisArg: Object, ...args: Object[]): Object }>\r\n}\r\n\r\ninterface BindVariableExpressionsMap {\r\n    [bindVariableName: string]: string[]\r\n}\r\n\r\nexport interface ObjectObservable {\r\n    lastActionMethod: string;\r\n    lastActionIndex: number;\r\n    lastActionObject: Object;\r\n    lastActionPropertyPath: string;\r\n    lastActionDerived: boolean;\r\n\r\n    _observableUniqueName: string;\r\n    _observers: Map<string, Map<HofHtmlElement, Map<string, string[]>>>;\r\n    _observersPropertyPaths: Map<HofHtmlElement, Map<string, string[]>>;\r\n}\r\n\r\nexport interface ArrayObservable<T> extends ObjectObservable {\r\n    _emit: (index: number, method: string, newValue: Object, oldValue: Object, action: Function) => Array<T>;\r\n\r\n    edit: (index: number, element: T) => T[];\r\n    delete: (index: number) => T[];\r\n}\r\n\r\n// Extend Object and Array<T> within the framework (not global, because extensions \r\n// are only usable within the context of an HofHtmlElement).\r\ntype Object = globalThis.Object & Partial<ObjectObservable>;\r\ntype Array<T> = globalThis.Array<T> & Partial<ArrayObservable<T>>;\r\n\r\ntype DOMElement = HTMLElement | Text | Node | HofHtmlElement;\r\n\r\ntype TemplateStringFunction = (listItemParameter?: Object) => string;\r\n\r\nclass AttributeExpression {\r\n    public constructor(public execute: Function,\r\n        public bindVariableNames: string[], public template: string) { }\r\n}\r\n\r\nclass CachedListData {\r\n    public constructor(public listParentElementName: string, public listParentElementRenderOnEmptyList: boolean,\r\n        public listProperty: string, public listDerived: boolean, public listFunction: Function, public listReferencedProps: Array<string>,\r\n        public listItemVariable: string, public listIndexVariable: string, public listItemUpdatedVariable: string,\r\n        public listElementTemplateFunction: TemplateStringFunction, public listElementTemplateSize: number) {}\r\n}\r\n\r\nclass CachedContentData {\r\n    public constructor(public contentTemplateFunction: TemplateStringFunction, public updatedVariable: string) {}\r\n}\r\n\r\nclass ListData {\r\n    public constructor(public listParentElement: Node, public listParentElementIndex: number,\r\n        public listCurrentData: Array<Object>) {}\r\n}\r\n\r\ninterface HofHtmlElementSubclass extends Function {\r\n    _cached: boolean;\r\n    _cachedInstanceId: number;\r\n    _cachedTemplates: Array<CachedListData|CachedContentData>;\r\n    _cachedLists: Map<string, Array<CachedListData>>;\r\n\r\n    _cachedPropertyReferences: Map<string, Object>; // Property names and initial values to allow list property identification based on value at first rendering\r\n}\r\n\r\nexport abstract class HofHtmlElement extends HTMLElement {\r\n    _instanceId = 0;\r\n    _tagName: string = null;\r\n    _root: HTMLElement = null;\r\n    _shadow: ShadowRoot = null;\r\n\r\n    _properties: PropertyMap = {}; // Global properties (of component)\r\n    _derivedProperties = {}; // All derived properties with their function definition\r\n    _allBindVariables: PropertyMap = null; // All bind variables with their current values\r\n    _allBindExpressions: BindVariableExpressionsMap = {}; // All bind variable expressions used in templates\r\n    _observersForBindVariable: Map<string, Map<DOMElement, string[]>> = new Map(); // Map<BindVariableName, Map<DOMElement, AttributeName[]>>\r\n    _observerExpressions: Map<DOMElement, Map<string, AttributeExpression>> = new Map(); // Map<DOMElement, Map<AttributeName, AttributeExpression>>\r\n\r\n    _renderIteration: number = -1; // Each rendering process increments id (rendering of a list of n elements means n incrementations, each update an additional one)\r\n    _lists: Map<string, ListData[]> = new Map();\r\n\r\n    _static: HofHtmlElementSubclass = null;\r\n\r\n    static REFERENCED_BIND_VARIABLE_NAMES_REGEX = new RegExp('([a-zA-Z_$][\\\\w]+\\\\.[\\\\w\\\\.]+[\\\\w])([\\\\.][\\\\w]+\\\\()?', 'g');\r\n    static HTML_TAGGED_TEMPLATE_REGEX = new RegExp(\"html\\\\s*`\", \"g\");\r\n\r\n    static PARENT_PROPERTIES: Array<string> = null; // Properties of HofHtmlElement to differentiate own properties of classes that extend HofHtmlElement\r\n\r\n    constructor(tagName: string = 'div') {\r\n        super();\r\n\r\n        // Only calculate properties of HofHtmlElement first time\r\n        if (HofHtmlElement.PARENT_PROPERTIES == null)\r\n            HofHtmlElement.PARENT_PROPERTIES = Object.getOwnPropertyNames(this);\r\n\r\n        this._static = this.constructor as HofHtmlElementSubclass;\r\n        if (typeof this._static._cached == \"undefined\") {\r\n            this._static._cached = false;\r\n            this._static._cachedInstanceId = 0;\r\n            this._static._cachedLists = new Map();\r\n            this._static._cachedTemplates = [];\r\n            this._static._cachedPropertyReferences = new Map();\r\n        }\r\n\r\n        this._instanceId = this._static._cachedInstanceId++;       \r\n        this._tagName = tagName;\r\n        this._root = document.createElement(this._tagName);\r\n        this._shadow = this.attachShadow({ mode: \"open\" });\r\n        this._shadow.appendChild(this._root);\r\n\r\n        this._makeDerivedPropertyFunctions();\r\n    }\r\n\r\n    connectedCallback() {\r\n        // Apply styles if provided\r\n        if (this.styles != null) {\r\n            const styles = document.createElement(\"style\");\r\n            styles.innerHTML = this.styles;\r\n            this._shadow.appendChild(styles);\r\n        }\r\n\r\n        // Make component properties observable including derived properties\r\n        this._makeComponentPropertiesObservable();\r\n        this._restoreDerivedPropertyFunctions();\r\n\r\n        // If HofHtmlElement is used in plain HTML markup and not within other HofHtmlElement,\r\n        // full render has to be called because no other HofHtmlElement manages call to render\r\n        if (this._isRootHofHtmlElement())\r\n            this.render();\r\n\r\n        this.init?.();\r\n    }\r\n\r\n    disconnectedCallback() {\r\n        this.dispose?.();\r\n    }\r\n\r\n    render() {\r\n        // This method only gets called one time for each component instance to\r\n        // make initial full rendering and setup observability\r\n\r\n        // Templates are only calculated once for each component class because\r\n        // they are the same for each instance of a component\r\n        if (!this._static._cached) { // First instance of component class used in html?\r\n            this._static._cached = true;\r\n            this._renderAndCacheTemplates();\r\n        }\r\n        else // Second instance of component class used in html?\r\n            this._renderCachedTemplates();\r\n\r\n        HofLogging.logInitialRendering(this, 0, this._properties);\r\n        HofLogging.logInitialRendering(this, 0, this._derivedProperties);\r\n        \r\n        // Property references are no longer needed because resolving is completed\r\n        this._static._cachedPropertyReferences = null;\r\n    }\r\n\r\n    _renderAndCacheTemplates() {\r\n         // Replace string template with function that returns string\r\n         if (typeof this.templates == \"string\") {\r\n            const implementation = this._static.toString();\r\n            const implementationWithTemplateFunction = implementation.replace(/templates\\s*=\\s*html\\s*`/m, \"static templates = () => html`\");\r\n            if (implementationWithTemplateFunction != implementation)\r\n                this.templates = new Function(\"return \" + implementationWithTemplateFunction)().templates;\r\n            else\r\n                throw Error(\"String templates are only allowed if you assign an html`` expression! If you require more features, assign a lambda expression such as () => someExpression.\");\r\n        }\r\n\r\n        // Array of render statements (templates = [...])?\r\n        if (Array.isArray(this.templates))\r\n            for (const template of this.templates)\r\n                this._renderAndCacheTemplate(template);\r\n        else // Only one render statement (templates = ...)\r\n            this._renderAndCacheTemplate(this.templates);\r\n    }\r\n\r\n    _renderAndCacheTemplate(template: Function|Object) {\r\n        if (template[\"bind\"]) // item render function?\r\n            this._renderAndCacheContent(template as TemplateStringFunction);\r\n        else { // list render function?\r\n            const listPropertyName = this._findPropertyForValue(template[\"list\"]);\r\n            const restoredGetter = Object.getOwnPropertyDescriptor(this, listPropertyName).get;\r\n\r\n            const listParentElementName = template[\"parentElement\"];\r\n            const renderParentElementOnEmptyList = template[\"renderParentElementOnEmptyList\"];\r\n\r\n            // Derived property? -> Resolve\r\n            const listPropertyFunction = this._derivedProperties[listPropertyName] ? \r\n                restoredGetter : new Function(`return this.${listPropertyName};`);\r\n   \r\n            // Render list\r\n            this._renderAndCacheList(listPropertyFunction, template[\"htmlRenderFunc\"], listParentElementName, renderParentElementOnEmptyList);\r\n        }\r\n    }\r\n\r\n    _renderCachedTemplates() {\r\n        for (const cachedTemplate of this._static._cachedTemplates)\r\n            if (\"contentTemplateFunction\" in cachedTemplate)\r\n                this._renderCachedContent(cachedTemplate)\r\n            else if (\"listElementTemplateFunction\" in cachedTemplate)\r\n                this._renderCachedList(cachedTemplate);\r\n            else\r\n                throw Error(\"Unsupported cached template!\")\r\n    }\r\n\r\n    templates: Array<Object>|string = [];\r\n    styles: string = null;\r\n    init: Function = null;\r\n    dispose: Function = null;\r\n\r\n    _isRootHofHtmlElement() {\r\n        // Look for HofHtmlElements above this HofHtmlElement\r\n        for (let node: ParentNode = this; node; node = node.parentNode)\r\n            if (node.toString() === \"[object ShadowRoot]\" && node[\"host\"] instanceof HofHtmlElement)\r\n                return false; // HofHtmlElement that contains this HofHtmlElement was found\r\n\r\n        // No HofHtmlElement was found above this element -> this element is root HofHtmlElement\r\n        return true;\r\n    }\r\n\r\n    _makeDerivedPropertyFunctions() {\r\n        // Replace derived properties (properties with only a getter) with functions that return getter\r\n        // to identify properties by their value in method _findPropertyForValue (simple values do not\r\n        // work because they can be \"\" or [] which is not unique, however function references are unique)\r\n        const prototype = Object.getPrototypeOf(this);\r\n        for (const name of Object.getOwnPropertyNames(prototype).filter(name => name != \"constructor\")) {\r\n            if (Object.getOwnPropertyDescriptor(prototype, name).get) {\r\n                Object.defineProperty(this, name, {\r\n                    get: function () { return Object.getOwnPropertyDescriptor(prototype, name).get },\r\n                    configurable: true\r\n                });\r\n                \r\n                this._derivedProperties[name] = Object.getOwnPropertyDescriptor(prototype, name).get;\r\n            }\r\n        }\r\n    }\r\n\r\n    _restoreDerivedPropertyFunctions() {\r\n        const prototype = Object.getPrototypeOf(this);               \r\n\r\n        for (const listPropertyName of Object.keys(this._derivedProperties)) {\r\n            const propDesc = Object.getOwnPropertyDescriptor(prototype, listPropertyName);   \r\n            if (this._derivedProperties[listPropertyName]) {\r\n                if (propDesc.get) {\r\n                    Object.defineProperty(this, listPropertyName, {\r\n                        get: this._derivedProperties[listPropertyName]\r\n                    });\r\n\r\n                    return Object.getOwnPropertyDescriptor(prototype, listPropertyName).get.bind(this);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    _findPropertyForValue(propertyValue: Object) {\r\n        if (propertyValue == null) return null;\r\n\r\n        for (const name of Object.getOwnPropertyNames(this))\r\n            if (propertyValue == this._static._cachedPropertyReferences.get(name))\r\n                return name;\r\n\r\n        for (const name of Object.getOwnPropertyNames(Object.getPrototypeOf(this)))\r\n            if (propertyValue == this._static._cachedPropertyReferences.get(name))\r\n                return name;\r\n        \r\n        throw Error(\"Property could not be resolved! If you used a private property with leading #, \"\r\n            + \"please replace it with _, because private properties are currently not supported within templates!\")\r\n    }\r\n\r\n    _makeComponentPropertiesObservable() {\r\n        // Replace all public simple properties with getters and setters,\r\n        // so that access can be intercepted and observability can be realized\r\n        this._forEachNonDerivedProperty((prop, obj) => {\r\n            const initialValue = obj[prop];\r\n \r\n            // Save initial property value for later property resolving\r\n            if (this._static._cachedPropertyReferences && !this._static._cachedPropertyReferences.has(prop))\r\n                this._static._cachedPropertyReferences.set(prop, initialValue);              \r\n                \r\n            // Replace property with observability supporting property (observe property assignments)\r\n            Object.defineProperty(this, prop, {\r\n                get: function () { return this.getBindVariable(prop, initialValue); },\r\n                set: function (value) {\r\n                    const oldValue = this.getBindVariable(prop, initialValue);\r\n                    if (this._callBindVariableBeforeChangedHook(this, prop, value, oldValue)) {\r\n                        this.setBindVariable(prop, value);\r\n                        this._callBindVariableAfterChangedHook(this, prop, value, oldValue);\r\n                    }\r\n                },\r\n                enumerable: true,\r\n                configurable: true\r\n            });\r\n\r\n            this._createObjectProxy(this, prop);\r\n        })\r\n    }\r\n\r\n    getBindVariable(name: string, initialValue: Object = undefined) {\r\n        if (this._allBindVariables)\r\n            return this._allBindVariables[name];\r\n\r\n        return this._properties[name] ?? this.getAttribute(name) as Object ?? initialValue;\r\n    }\r\n\r\n    setBindVariable(name: string, value: Object) {\r\n        const oldValue = this.getBindVariable(name);\r\n\r\n        // Update property in case of complex object (because part of it has changed) or on value change of simple property or on collection action\r\n        if (typeof (oldValue) == \"object\" || typeof (value) == \"object\" || oldValue != value || value[\"lastActionMethod\"]) {\r\n            // Only update property if it was changed and not only subproperty\r\n            if (!value.lastActionPropertyPath) {\r\n                // Process initial element-property setter calls (cache for time after template\r\n                // has been constructed and further binding variables are available)\r\n                this._properties[name] = value;\r\n                \r\n                // Update properties including local binding variables\r\n                if (this._allBindVariables)\r\n                    this._allBindVariables[name] = value;\r\n            }\r\n\r\n            HofLogging.logPropertyUpdate(this, name, value);\r\n        }\r\n\r\n        // Make new objects observable\r\n        if (this._allBindVariables)\r\n            this._makeBindVariableObservable(name);\r\n\r\n        // Inform observers on property update\r\n        this._updatePropertyObservers([name, value]);\r\n\r\n        // Render update\r\n        this._renderUpdate(name, value, oldValue);\r\n    }\r\n\r\n    _renderAndCacheContent(html: TemplateStringFunction) {\r\n        const expression = html.toString();\r\n\r\n        // Extract variable names for updated from template function, e.g. (updated) => ...\r\n        // (parameter has to be identified by =>, because some browsers/node return parameter without brackets in function.toString())\r\n        const [updatedVariable] = expression.substring(0, expression.indexOf(\"=>\"))\r\n            .replace(\"(\", \"\").replace(\")\", \"\").split(\",\").map(x => x.trim());\r\n        \r\n        const cachedContentData = new CachedContentData(html, updatedVariable);\r\n\r\n        this._renderCachedContent(cachedContentData);\r\n\r\n        this._static._cachedTemplates.push(cachedContentData);\r\n    }\r\n\r\n    _renderCachedContent(cachedContentData: CachedContentData) {\r\n        const locals = {};\r\n\r\n        if (cachedContentData.updatedVariable) {\r\n            let initValue = false;\r\n            locals[cachedContentData.updatedVariable] = initValue;\r\n\r\n            if (cachedContentData.updatedVariable in this)\r\n                throw Error(`Lambda parameter for updated state must not be named like existing property of component! `\r\n                    + `If you want to keep property name \"${cachedContentData.updatedVariable}\", use another lambda parameter name.`);\r\n\r\n            Object.defineProperty(this, this._calculateRenderingIterationAwareUniqueName(cachedContentData.updatedVariable), {\r\n                get: function () { const oldValue = initValue; if (!initValue) initValue = true; return oldValue; }\r\n            });\r\n        }\r\n\r\n        this._renderFull(this._root, cachedContentData.contentTemplateFunction, locals);\r\n    }\r\n\r\n    _renderAndCacheList(listFunction: Function, listElementTemplateFunction: TemplateStringFunction, listParentElementName: string, listParentElementRenderOnEmptyList: boolean) {\r\n        const expression = listElementTemplateFunction.toString();\r\n\r\n        // Extract variable names for item and index from list element template function, e.g. (person, index) => ...\r\n        // (list parameter has to be identified by =>, because some browsers/node return parameter without brackets in function.toString())\r\n        const [listItemVariable, listIndexVariable, listItemUpdatedVariable] = expression.substring(0, expression.indexOf(\"=>\"))\r\n            .replace(\"(\", \"\").replace(\")\", \"\").split(\",\").map(x => x.trim());\r\n\r\n        // Support derived properties as list parameters\r\n        const listExpression = listFunction.toString();       \r\n\r\n        // Calculate variable names\r\n        const listReferencedProps = [];\r\n        for (const [, prop] of listExpression.matchAll(/this\\.(\\w+)/gm))\r\n            listReferencedProps.push(prop);\r\n\r\n        const listDerived = listExpression.startsWith(\"get \");\r\n        const listProperty = listDerived\r\n            ? listFunction.name.substring(4).trim() // derived property name\r\n            : listReferencedProps[0];\r\n\r\n        const cachedListData = new CachedListData(\r\n            listParentElementName, listParentElementRenderOnEmptyList,\r\n            listProperty, listDerived, listFunction, listReferencedProps,\r\n            listItemVariable, listIndexVariable, listItemUpdatedVariable,\r\n            listElementTemplateFunction, 0\r\n        )\r\n\r\n                // Create entry for list properties\r\n                for (const listProp of listReferencedProps) {\r\n                    const cachedLists = this._static._cachedLists;\r\n        \r\n                    if (!cachedLists.has(listProp))\r\n                        cachedLists.set(listProp, []);\r\n        \r\n                    cachedLists.get(listProp).push(cachedListData);      \r\n                }\r\n        \r\n                this._static._cachedTemplates.push(cachedListData);\r\n\r\n        cachedListData.listElementTemplateSize = this._renderCachedList(cachedListData);\r\n\r\n\r\n    }\r\n\r\n    _getFilteredProperties(propNames: string[]) {\r\n        return Object.fromEntries(Object.entries(this._allBindVariables).filter(([key,]) => propNames.includes(key)));\r\n    }\r\n\r\n    _renderCachedList(cachedListData: CachedListData) {\r\n        const listData = (cachedListData.listFunction as any).call(this) as Array<Object>;\r\n\r\n        // Add observability for list changes to this HofHtmlElement\r\n        this._addBindExpressionForLists(cachedListData.listDerived ? cachedListData.listReferencedProps : [cachedListData.listProperty]);\r\n\r\n        let i = 0; const locals = {};\r\n        const listParentElement = document.createElement(cachedListData.listParentElementName);\r\n        for (const listItem of listData) {\r\n            locals[cachedListData.listItemVariable] = listItem;\r\n            locals[cachedListData.listItemVariable]._observableUniqueName = this._calculateRenderingIterationAwareUniqueName(cachedListData.listItemVariable);\r\n            if (cachedListData.listIndexVariable) locals[cachedListData.listIndexVariable] = i;\r\n            if (cachedListData.listItemUpdatedVariable) locals[cachedListData.listItemUpdatedVariable] = false;\r\n\r\n            this._renderFull(listParentElement, cachedListData.listElementTemplateFunction, locals); i++;\r\n        }\r\n\r\n        // Render parent element depending on list size\r\n        if (cachedListData.listParentElementRenderOnEmptyList || listData.length > 0)\r\n            this._root.appendChild(listParentElement);\r\n\r\n        const listParentElementIndex = this._root.childNodes.length;\r\n\r\n        // Create entry for list properties\r\n        for (const listProp of cachedListData.listReferencedProps) {\r\n            if (!this._lists.has(listProp)) this._lists.set(listProp, []);\r\n            this._lists.get(listProp).push(new ListData(\r\n                listParentElement, listParentElementIndex, [...listData]\r\n            ));\r\n        }\r\n        \r\n        const listElementTemplateSize = i > 0        \r\n            ? listParentElement.childNodes.length / i\r\n            : this._parseHTML(cachedListData.listElementTemplateFunction, locals)[0].length;\r\n\r\n        return listElementTemplateSize;\r\n    }\r\n\r\n    _addBindExpressionForLists(listProps: Array<string>) {\r\n        for (const listProp of listProps) {\r\n            if (!(listProp in this._allBindExpressions))\r\n                this._allBindExpressions[listProp] = [];\r\n            \r\n            if (!this._allBindExpressions[listProp].includes(\"length\"))\r\n                this._allBindExpressions[listProp].push(\"length\");\r\n        }\r\n    }\r\n\r\n    _calculateBindVariables() {\r\n        let result = {};\r\n        this._forEachNonDerivedProperty((prop, obj) => result[prop] = obj[prop] );\r\n\r\n        this._allBindVariables = result;\r\n    }\r\n\r\n    _forEachNonDerivedProperty(func: (prop: string, obj: Object) => void) {\r\n        for (const name of Object.getOwnPropertyNames(this).filter(p => !HofHtmlElement.PARENT_PROPERTIES.includes(p))) {\r\n            const propDesc = Object.getOwnPropertyDescriptor(this, name)\r\n            if (!propDesc.get || propDesc.configurable)\r\n                func(name, this);\r\n        }\r\n\r\n        const prototype = Object.getPrototypeOf(this);\r\n        for (const name of Object.getOwnPropertyNames(prototype).filter(p => p != \"constructor\")) {\r\n            if (!Object.getOwnPropertyDescriptor(prototype, name).get)\r\n                func(name, prototype);\r\n        }\r\n    }\r\n\r\n    _convertToTemplateExpression(buildFunction: TemplateStringFunction) {\r\n        let expression = buildFunction.toString();\r\n\r\n        // Support quotes within attribute expressions\r\n        for (const [, match] of expression.matchAll(/(html`[\\s\\S]*`\\s*\\}\\s*)\"/g))\r\n            expression = expression.replace(match, match.replaceAll(\"\\\"\", \"&quot;\"));\r\n\r\n        // Check if template function is a regular function or an arrow function and calculate start of expression\r\n        const isRegularFunction = expression.startsWith(\"function\");\r\n        const expressionStart = isRegularFunction ? expression.indexOf(\"return\"): expression.indexOf(\"=>\");\r\n        if (expressionStart == -1)\r\n            throw Error(`Render function definition '${expression}' is not valid! It has to be of type arrow function (optionalParams) => string or of type function() { return string }.`);\r\n\r\n        // Extract function body and interpret as expression\r\n        expression = isRegularFunction\r\n            ? expression.substring(expressionStart + 6, expression.lastIndexOf(\"}\"))\r\n            : expression.substring(expressionStart + 2);\r\n        expression = expression.trim();\r\n\r\n        // Remove tagged template literal prefix if html`` is used\r\n        expression = expression.replaceAll(HofHtmlElement.HTML_TAGGED_TEMPLATE_REGEX, \"`\");\r\n\r\n        // If expression is template literal, return content\r\n        if (expression.startsWith(\"`\") && expression.endsWith(\"`\"))\r\n            expression = expression.substring(1, expression.length-1);\r\n        else // If expression is regular code, wrap it into template literal tokens\r\n            expression = \"${\" + expression + \"}\";\r\n\r\n        return expression.trim();\r\n    }\r\n\r\n    _parseHTML(htmlFunction: TemplateStringFunction, locals: PropertyMap): [NodeListOf<ChildNode>, PropertyMap, string[]] {\r\n        const html = this._convertToTemplateExpression(htmlFunction);\r\n\r\n        // First call of render?\r\n        if (this._allBindVariables == null)\r\n            this._calculateBindVariables();\r\n\r\n        const allBindVariables = this._allBindVariables;\r\n        const [template, bindVariableNames] = this._calculateTemplateAndBindVariableNames(html, allBindVariables, locals);\r\n\r\n        this._calculateBindings(template, bindVariableNames);\r\n\r\n        let temp = document.createElement('template');\r\n        temp.innerHTML = template;\r\n        const elements = temp.content.childNodes;\r\n\r\n        this._renderIteration++;\r\n\r\n        return [elements, allBindVariables, bindVariableNames];\r\n    }\r\n\r\n    _makeBindVariableObservable(bindVariableName: string) {\r\n        // Don't make derived properties observable because they are updated in case referenced bind variables update\r\n        if (this._derivedProperties[bindVariableName]) return;\r\n\r\n        for (const bindingExpression of this._allBindExpressions[bindVariableName])\r\n            this._makeBindVariableStructureObservable(bindVariableName, bindingExpression);\r\n    }\r\n\r\n    _makeBindVariableStructureObservable(bindVariableName: string, bindingExpression: string) {\r\n        const o = this._allBindVariables[bindVariableName];\r\n        const props = bindingExpression.split('.');\r\n\r\n        // Walk through property path and make subproperties observable\r\n        let propObj = o; let propertyPath = bindVariableName;\r\n        for (let i = 0; i < props.length; i++) {\r\n            let lastProp = props[i]; propertyPath += `.${props[i]}`;\r\n\r\n            if (typeof propObj == \"undefined\") return;\r\n\r\n            if (typeof propObj == 'object') {\r\n                // Bind this of nested properties to parent property\r\n                if (!Array.isArray(propObj) && propertyPath.includes(\".\") && propObj[lastProp].bind)\r\n                    propObj[lastProp] = propObj[lastProp].bind(propObj);\r\n\r\n                // Do not observe function references\r\n                if (propObj[lastProp][\"bind\"]) continue;\r\n\r\n                // Observe arrays and objects\r\n                if (!Array.isArray(propObj))\r\n                    this._makeObjectPropertyObservable(propObj, lastProp, bindVariableName, propertyPath);\r\n                else\r\n                    this._makeArrayPropertyObservable(propObj, lastProp, bindVariableName, propertyPath);\r\n\r\n                // Create object proxy for property\r\n                this._createObjectProxy(propObj, lastProp);\r\n            }\r\n\r\n            propObj = propObj[props[i]];\r\n        }\r\n    }\r\n\r\n    _createObjectProxy(propObj: Object, lastProp: string) {\r\n        // Currently only arrays require a proxy to observe index setter calls\r\n        if (!Array.isArray(propObj[lastProp]))\r\n            return;\r\n\r\n        if (propObj[lastProp][\"__isProxy\"])\r\n            return;\r\n\r\n        Object.defineProperty(propObj, lastProp, {\r\n            value: new Proxy(propObj[lastProp], {\r\n                set(o: Array<Object>, prop: string, value: Object) {\r\n                    if (o._emit && !isNaN(prop as any)) {\r\n                        const index = parseInt(prop);\r\n                        if (index > o.length)\r\n                            throw Error(`You cannot add an element at index ${index} because elements before would get the value undefined and this cannot be observed!`);\r\n                        else if (typeof(value) == \"undefined\" || value[\"_spliceAction\"] == \"DELETE\")\r\n                            o._emit(index, \"DELETE\", null, o[index], () => Array.prototype.splice.call(o, index, 1));\r\n                        else if (index == o.length || value[\"_spliceAction\"] == \"ADD\") // Add\r\n                            o._emit(index, \"ADD\", value, null, () => Array.prototype.splice.call(o, index, 0, value));\r\n                        else\r\n                            o._emit(index, \"EDIT\", value, o[index], () => Array.prototype.splice.call(o, index, 1, value));\r\n\r\n                        if (typeof(value) != \"undefined\")\r\n                            value[\"_spliceAction\"] = undefined;\r\n                    }\r\n                    else\r\n                        o[prop] = value;                        \r\n\r\n                    // Indicate success\r\n                    return true;\r\n                },\r\n                get(target, key) {\r\n                    if (key !== \"__isProxy\") {\r\n                        return target[key];\r\n                    }\r\n            \r\n                    return true;\r\n                }\r\n            }), enumerable: true, configurable: true\r\n        });   \r\n    }\r\n\r\n    _callBindVariableBeforeChangedHook(obj: Object, prop: string, newValue: Object, oldValue: Object|string) {\r\n        // Initial call / property not yet resolved -> dont execute hook\r\n        if (typeof oldValue == \"string\" && oldValue.startsWith(\"$\")) return true;\r\n\r\n        const hookMethodName = `${prop}BeforeChanged`;\r\n        if (obj[hookMethodName]) {\r\n            const ret = obj[hookMethodName](newValue, oldValue);\r\n            if (typeof ret != \"undefined\" && ret == false)\r\n                return false;\r\n\r\n            return true;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    _callBindVariableAfterChangedHook(obj: Object, prop: string, newValue: Object, oldValue: Object|string) {\r\n        // Initial call / property not yet resolved -> dont execute hook\r\n        if (typeof oldValue == \"string\" && oldValue.startsWith(\"$\")) return;\r\n\r\n        const hookMethodName = `${prop}AfterChanged`;\r\n        if (obj[hookMethodName])\r\n            obj[hookMethodName](newValue, oldValue);\r\n    }\r\n\r\n    _callBindVariableBeforePropertyChangedHook(obj: Object, prop: string, subProp: string, newValue: Object, oldValue: Object|string) {\r\n        // Initial call / property not yet resolved -> dont execute hook\r\n        if (typeof oldValue == \"string\" && oldValue.startsWith(\"$\")) return true;\r\n\r\n        const hookMethodName = `${prop}BeforePropertyChanged`;\r\n        if (obj[hookMethodName]) {\r\n            const ret = obj[hookMethodName](subProp, newValue, oldValue);\r\n            if (typeof ret != \"undefined\" && ret == false)\r\n                return false;\r\n\r\n            return true;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    _callBindVariableAfterPropertyChangedHook(obj: Object, prop: string, subProp: string, newValue: Object, oldValue: Object|string) {\r\n        // Initial call / property not yet resolved -> dont execute hook\r\n        if (typeof oldValue == \"string\" && oldValue.startsWith(\"$\")) return;\r\n\r\n        const hookMethodName = `${prop}AfterPropertyChanged`;\r\n        if (obj[hookMethodName])\r\n            obj[hookMethodName](subProp, newValue, oldValue);\r\n    }\r\n\r\n    _makeObjectPropertyObservable(obj: Object, observerProperty: string, componentProperty: string, propertyPath: string) {\r\n        let _value = obj[observerProperty];\r\n\r\n        const self = this;\r\n\r\n        // Register new observer if not already registered\r\n        this._registerNewObserver(obj, observerProperty, this, componentProperty, propertyPath);\r\n        \r\n        // Replace property with property that calls all registered observers\r\n        if (!Object.getOwnPropertyDescriptor(obj, observerProperty).set && !Object.getOwnPropertyDescriptor(obj, observerProperty).get) {\r\n            Object.defineProperty(obj, observerProperty, {\r\n                get: function () { return _value; }.bind(this),\r\n                set: function (v: Object) {\r\n                    const newValue = v;\r\n                    const oldValue = obj[observerProperty];\r\n\r\n                    self._applyValueAndNotifyObservers(obj, observerProperty, componentProperty, newValue, oldValue, false, () => _value = v);\r\n                }.bind(this),\r\n                enumerable: true,\r\n                configurable: true\r\n            });\r\n    \r\n            // Adapt binding for methods in properties, so methods use this of surrounding object literal\r\n            // if (propertyPath.includes(\".\") && obj[observerProperty].bind)\r\n            //     obj[observerProperty] = obj[observerProperty].bind(obj);\r\n        }\r\n    }\r\n\r\n    _makeArrayPropertyObservable(arr: Array<Object>, observerProperty: string, componentProperty: string, propertyPath: string) {\r\n        const self = this;\r\n        if (!this._registerNewObserver(arr, observerProperty, this, componentProperty, propertyPath)) {\r\n            arr._emit = function (index: number, method: string, newValue: Object, oldValue: Object, action: Function) {\r\n                this.lastActionIndex = index;\r\n                this.lastActionMethod = method;\r\n                this.lastActionObject = method == \"DELETE\" ? oldValue : newValue;\r\n\r\n                self._applyValueAndNotifyObservers(this, observerProperty, componentProperty, newValue, oldValue, true, action);\r\n\r\n                // Reset action\r\n                this.lastActionMethod = null; this.lastActionIndex = null; this.lastActionObject = null; this.lastActionPropertyPath = null;\r\n\r\n                return this;\r\n            }\r\n            arr.push = function (...items: Object[]) {\r\n                this.splice(this.length, 0, ...items);\r\n                return this.length;\r\n            };\r\n            arr.splice = function (index: number, deleteCount: number, ...items: Object[]) {\r\n                const deletedItems = this.slice(index, index + deleteCount);\r\n\r\n                let i = 0;\r\n                for (i=0; i<Math.min(items.length, deletedItems.length); i++) {\r\n                    items[i][\"_spliceAction\"] = \"EDIT\";\r\n                    this[index+i] = items[i];\r\n                }\r\n\r\n                for (let j=i; j<deletedItems.length; j++) {\r\n                    this[index+i] = undefined;\r\n                }\r\n\r\n                for (let j=i; j<items.length; j++) {\r\n                    items[i][\"_spliceAction\"] = \"ADD\";\r\n                    this[index+j] = items[j];\r\n                }\r\n\r\n                return deletedItems;\r\n            }\r\n            arr.edit = function (index, el) { return this.splice(index, 1, el); };\r\n            arr.delete = function (index) { return this.splice(index, 1); };\r\n\r\n            arr.filter = function<S extends Object>(predicate: (value: Object, index: number, array: Object[]) => value is S): S[] {\r\n                const result = Array.prototype.filter.call(this, predicate);\r\n\r\n                // Keep lastActionIndex etc. to enable partial rerendering of filtered/mapped arrays\r\n                result.lastActionMethod = this.lastActionMethod;\r\n                result.lastActionIndex = this.lastActionIndex;\r\n                result.lastActionObject = this.lastActionObject;\r\n                result.lastActionDerived = true;\r\n                \r\n                return result;\r\n            }\r\n        }\r\n    }\r\n\r\n    _applyValueAndNotifyObservers(obj: Object, observerProperty: string, componentProperty: string, newValue: Object, oldValue: object, arrayNotification: boolean, action: Function) {\r\n        if (!this._callBindVariableBeforeChangedHook(obj, observerProperty, newValue, oldValue)\r\n            || !this._callBindVariableBeforePropertyChangedHook(this, componentProperty, observerProperty, newValue, oldValue))\r\n            return;\r\n\r\n        action();\r\n\r\n        obj._observers.get(observerProperty).forEach((componentDetails, component) => {\r\n            componentDetails.forEach((componentPropertyPaths, componentProperty) => {\r\n                componentPropertyPaths.forEach(componentPropertyPath => {\r\n                    // On arrays if length property is changed, array ist changed, so adapt\r\n                    // property path to match expressions depending on array instead of array.length property\r\n                    if (arrayNotification)\r\n                        componentPropertyPath = componentPropertyPath.replace(\".length\", \"\");\r\n\r\n                    let bindVariableValue = component.getBindVariable(componentProperty);\r\n                    if (bindVariableValue) {\r\n                        if (!arrayNotification) bindVariableValue.lastActionMethod = \"SET\";\r\n\r\n                        bindVariableValue.lastActionPropertyPath = componentPropertyPath;\r\n                        \r\n                        // Don't assign componentProperty, but use setBindVariable (because bound locals\r\n                        // are not exposed as public properties but are observed as bind variables, e.g. person__it0, person__it1, ...)\r\n                        // component[componentProperty] = bindVariableValue;\r\n                        component.setBindVariable(componentProperty, bindVariableValue);\r\n\r\n                        if (!arrayNotification) bindVariableValue.lastActionMethod = null;\r\n                        bindVariableValue.lastActionPropertyPath = null;\r\n                    }\r\n                });\r\n            });\r\n        });\r\n\r\n        this._callBindVariableAfterPropertyChangedHook(this, componentProperty, observerProperty, newValue, oldValue);\r\n        this._callBindVariableAfterChangedHook(obj, observerProperty, newValue, oldValue);\r\n    }\r\n\r\n    _registerNewObserver(obj: Object | Array<Object>, observerProperty: string, component: HofHtmlElement, componentProperty: string, componentPropertyPath: string) {\r\n        let propertyAlreadyObserved = true;\r\n        if (!obj._observers) obj._observers = new Map();\r\n        if (!obj._observers.has(observerProperty)) {\r\n            obj._observers.set(observerProperty, new Map());\r\n            propertyAlreadyObserved = false;\r\n        }\r\n        if (!obj._observers.get(observerProperty).has(component)) obj._observers.get(observerProperty).set(component, new Map());\r\n        if (!obj._observers.get(observerProperty).get(component).has(componentProperty)) obj._observers.get(observerProperty).get(component).set(componentProperty, []);\r\n\r\n        const objObserverList = obj._observers.get(observerProperty).get(component).get(componentProperty);\r\n        if (!objObserverList.includes(componentPropertyPath))\r\n            objObserverList.push(componentPropertyPath);\r\n\r\n        return propertyAlreadyObserved;\r\n    }\r\n\r\n    _calculateBindings(htmlFunction: string, bindVariableNames: string[]) {\r\n        for (let bindVariableName of bindVariableNames) {\r\n            const regexp = new RegExp(`(${bindVariableName})((\\\\.[\\\\w]+)+)`, 'g');\r\n           \r\n            if (!this._allBindExpressions[bindVariableName])\r\n                this._allBindExpressions[bindVariableName] = [];\r\n\r\n            for (const [, , expression] of htmlFunction.matchAll(regexp)) {\r\n                const expr = expression.substring(1);\r\n\r\n                if (!this._allBindExpressions[bindVariableName].includes(expr))\r\n                    this._allBindExpressions[bindVariableName].push(expr);\r\n            }\r\n\r\n            this._makeBindVariableObservable(bindVariableName);\r\n        }\r\n    }\r\n\r\n    _renderFull(parentElement: Node, htmlFunction: TemplateStringFunction, locals: PropertyMap) {\r\n        const [elements, bindVariables, bindVariableNames] = this._parseHTML(htmlFunction, locals);\r\n\r\n        const lastExistingElement = parentElement.childNodes.length;\r\n\r\n        while (elements.length > 0) // Elements are extracted from source at appendChild, therefore always first element\r\n            parentElement.appendChild(elements[0]);\r\n\r\n        // Incrementally process only those elements recursively that have not been processed via\r\n        // previous renderList or renderContent method within the same render method, so that the\r\n        // same elements are not processed multiple times and added to the observables data structure.\r\n        for (let index = lastExistingElement; index < parentElement.childNodes.length; index++)\r\n            this._processElementBinding(parentElement.childNodes[index], bindVariables, bindVariableNames);\r\n    }\r\n\r\n    _removeObserversForBindVariable(bindVariableToDelete: string) {\r\n        // Remove observer expressions\r\n        if (this._observersForBindVariable.has(bindVariableToDelete))\r\n            for (const [comp] of this._observersForBindVariable.get(bindVariableToDelete)) {\r\n                for (const [attr, expr] of this._observerExpressions.get(comp))\r\n                    if (expr.bindVariableNames.includes(bindVariableToDelete))\r\n                        this._observerExpressions.get(comp).delete(attr);\r\n\r\n                if (this._observerExpressions.get(comp).size == 0)\r\n                    this._observerExpressions.delete(comp);\r\n            }\r\n\r\n        // Remove observers for bind variable\r\n        this._observersForBindVariable.delete(bindVariableToDelete);\r\n\r\n        // Remove bind variable\r\n        delete this._allBindVariables[bindVariableToDelete];\r\n\r\n        // Remove all bind expressions for bind variable\r\n        delete this._allBindExpressions[bindVariableToDelete];\r\n    }\r\n\r\n    _calculateArrayChange(value: Array<Object>, oldValue: Array<Object>) {\r\n        if (value.length > oldValue.length)\r\n            value.lastActionMethod = \"ADD\";\r\n        else if (value.length < oldValue.length)\r\n            value.lastActionMethod = \"DELETE\";\r\n        else\r\n            value.lastActionMethod = \"EDIT\";\r\n\r\n        // Compare arrays\r\n        const maxArray = value.lastActionMethod == \"DELETE\" ? oldValue : value;\r\n        for (let i = 0; i < maxArray.length; i++)\r\n            if (value[i] != oldValue[i]) {\r\n                value.lastActionIndex = i;\r\n                value.lastActionObject = maxArray[i];\r\n                \r\n                // Return calculated action details\r\n                return value;\r\n            }\r\n\r\n        // No update action required because arrays are identical\r\n        value.lastActionMethod = \"NONE\";\r\n\r\n        return value;\r\n    }\r\n\r\n    _renderUpdate(listProp: string, value: Object, oldValue: Object) {\r\n        // If oldValue or initial value is of type array and this component\r\n        // is a list component, do partial rendering (otherwise no action is required\r\n        // because if no list is involved, no new html tags have to be created and\r\n        // simple property update and existing dom element attribute update are enough)\r\n        if (Array.isArray(oldValue) && this._lists.size > 0) {\r\n            let elementsBeforeShift = 0;\r\n\r\n            // Update all lists depending on changed property, if property is used in rendered list\r\n            if (this._lists.has(listProp))\r\n                for (let i=0; i < this._lists.get(listProp).length; i++) {\r\n                    elementsBeforeShift = this._renderListUpdate(\r\n                        this._lists.get(listProp)[i], this._static._cachedLists.get(listProp)[i], value as Array<Object>, elementsBeforeShift);\r\n                    \r\n                    this._lists.get(listProp)[i].listParentElementIndex += elementsBeforeShift;\r\n                }\r\n        }\r\n    }\r\n\r\n    _renderListUpdate(listData: ListData, cachedListData: CachedListData, value: Array<Object>, elementsBeforeShift: number) {\r\n        // If rendered list does not map directly to original array because of intermediate mapping, filtering etc.\r\n        // action properties such as value.lastActionIndex are not available or cannot be used and have to be\r\n        // calculated by applying comparison between elements of old and new mapped array\r\n        const renderDerivedValue = cachedListData.listDerived || value.lastActionDerived;\r\n        \r\n        if (renderDerivedValue) {\r\n            const lastActionIndexBeforeMapping = value.lastActionIndex;\r\n\r\n            // Apply mapping function\r\n            value = cachedListData.listFunction.call(this);\r\n\r\n            // Caluclate array changes if not complete array reassignment was triggered\r\n             if (typeof lastActionIndexBeforeMapping != \"undefined\")\r\n                 value = this._calculateArrayChange(value, listData.listCurrentData);\r\n        }\r\n\r\n        // Change in list does not regard rendered content (e.g. no change in already rendered items)?\r\n        if (value.lastActionMethod == \"NONE\") return elementsBeforeShift;\r\n\r\n        // Partial rendering of added, updated or deleted element\r\n        if (typeof value.lastActionIndex != \"undefined\") {\r\n            this._renderListElementUpdate(listData, cachedListData, value);\r\n\r\n            HofLogging.logRenderUpdate(this, cachedListData.listProperty, value,\r\n                renderDerivedValue ? \"Partial (search) rerender\" : \"Partial (index) rerender\");\r\n        }\r\n        else { // Full rerendering, because Array was not modified by adding, deleting or updating one item, but by reassigning a new array  \r\n            // Remove all old elements\r\n            value.lastActionMethod = \"DELETE\";\r\n            for (let i=0; i<listData.listCurrentData.length; i++) {\r\n                value.lastActionIndex = 0; value.lastActionObject = listData.listCurrentData[i];\r\n                this._renderListElementUpdate(listData, cachedListData, value);\r\n            }\r\n\r\n            // Insert new array elements\r\n            value.lastActionMethod = \"ADD\";\r\n            for (let i=0; i<value.length; i++) {\r\n                value.lastActionIndex = i;\r\n                this._renderListElementUpdate(listData, cachedListData, value);\r\n            }\r\n\r\n            // Reset, so next list has some data\r\n            value.lastActionMethod = undefined; value.lastActionIndex = undefined; value.lastActionObject = undefined;\r\n\r\n            HofLogging.logRenderUpdate(this, cachedListData.listProperty, value, \"Full rerender\");\r\n        }\r\n\r\n        // Save copy to allow comparison with old value on next update for mapped arrays and to support full rendering\r\n        // on assignment of a new array instead of adding, editing or deleting one element of array\r\n        listData.listCurrentData = [...value];\r\n\r\n        // Update list parent element depending on list element size\r\n        return this._renderListParentUpdate(listData, cachedListData, elementsBeforeShift);\r\n    }\r\n\r\n    _renderListParentUpdate(listData: ListData, cachedListData: CachedListData, elementsBeforeShift: number) {\r\n        const oldRootElementCount = this._root.childNodes.length;\r\n\r\n        // Only change rendering if parent element should be rendered based on list size\r\n        if (!cachedListData.listParentElementRenderOnEmptyList) {\r\n            // If list is empty, remove parent element, because no empty ul-elements etc are allowed\r\n            // and if list is not empty but parent element not rendered, add it\r\n            if (listData.listParentElement.childNodes.length == 0) {\r\n                if (this._root.contains(listData.listParentElement))\r\n                    this._root.removeChild(listData.listParentElement);\r\n            }\r\n            else {\r\n                if (!this._root.contains(listData.listParentElement)) {\r\n                    if (this._root.childNodes[listData.listParentElementIndex + elementsBeforeShift])\r\n                        this._root.insertBefore(listData.listParentElement, this._root.childNodes[listData.listParentElementIndex + elementsBeforeShift]);\r\n                    else\r\n                        this._root.appendChild(listData.listParentElement); \r\n                }\r\n            }\r\n        }\r\n\r\n        return this._root.childNodes.length - oldRootElementCount + elementsBeforeShift;\r\n    }\r\n\r\n    _renderListElementUpdate(listData: ListData, cachedListData: CachedListData, value: Array<Object>) {\r\n        // Remove node\r\n        if (value.lastActionMethod == \"DELETE\") {\r\n            this._removeObserversForBindVariable(value.lastActionObject._observableUniqueName);\r\n\r\n            // Remove all nodes of item at index\r\n            const elementChangeIndex = value.lastActionIndex * cachedListData.listElementTemplateSize;\r\n            for (let i=0; i<cachedListData.listElementTemplateSize; i++) \r\n                listData.listParentElement.childNodes[elementChangeIndex].remove();\r\n        }\r\n        else {\r\n            const locals = {};\r\n            locals[cachedListData.listItemVariable] = value[value.lastActionIndex];\r\n            locals[cachedListData.listItemVariable]._observableUniqueName = this._calculateRenderingIterationAwareUniqueName(cachedListData.listItemVariable);\r\n            if (cachedListData.listIndexVariable) locals[cachedListData.listIndexVariable] = value.lastActionIndex;\r\n            if (cachedListData.listItemUpdatedVariable) locals[cachedListData.listItemUpdatedVariable] = true;\r\n\r\n            // Parse new html for added or updated content\r\n            const [elements, bindVariables, bindVariableNames] = this._parseHTML(cachedListData.listElementTemplateFunction, locals);\r\n            cachedListData.listElementTemplateSize = elements.length;\r\n\r\n            const elementChangeIndex = value.lastActionIndex * cachedListData.listElementTemplateSize;\r\n            for (let i=0; i<cachedListData.listElementTemplateSize; i++) {  \r\n                // Add or replace html (elements are extracted from source at appendChild, therefore always first element)\r\n                if (value.lastActionMethod == \"ADD\") {\r\n                    if (listData.listParentElement.childNodes[value.lastActionIndex])\r\n                        listData.listParentElement.insertBefore(elements[0], listData.listParentElement.childNodes[elementChangeIndex + i]);\r\n                    else\r\n                        listData.listParentElement.appendChild(elements[0]);\r\n\r\n                    this._processElementBinding(listData.listParentElement.childNodes[elementChangeIndex + i], bindVariables, bindVariableNames);\r\n                }\r\n                else if (value.lastActionMethod == \"EDIT\") {\r\n                    listData.listParentElement.replaceChild(elements[0], listData.listParentElement.childNodes[elementChangeIndex + i])\r\n                    this._processElementBinding(listData.listParentElement.childNodes[elementChangeIndex + i], bindVariables, bindVariableNames);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    _makeDerivedVariablesObservable(path: string, variableName: string, variableBody: string, html: string, functionWrappedGetter: boolean) {\r\n        // Make derived bind variables observable by adding referenced bind variables to template\r\n        let referencedBindVariableNames = \"/* references: \";\r\n        for (const [, referencedBindVariableName] of variableBody.matchAll(HofHtmlElement.REFERENCED_BIND_VARIABLE_NAMES_REGEX))\r\n            referencedBindVariableNames += `${path}.${referencedBindVariableName.replace(\"this.\", \"\")}; `;\r\n            referencedBindVariableNames += \"*/\"\r\n\r\n        return html.replaceAll(new RegExp(`([^\\\\w])${path}\\\\.${variableName}([^\\\\w])`, \"g\"),\r\n            `$1(${path}${functionWrappedGetter ? \"()\" : \"\"}.${variableName} ${referencedBindVariableNames} )$2`);\r\n    }\r\n\r\n    _calculateRenderingIterationAwareUniqueName(name: string) {\r\n        return name + \"__it\" + (this._renderIteration+1);\r\n    }\r\n\r\n    _calculateTemplateAndBindVariableNames(html: string, props: PropertyMap, locals: PropertyMap): [string, string[]] {\r\n        // Determine all binding variables\r\n        const bindVariables = Object.keys(props);\r\n\r\n        // Add additional local variables to binding\r\n        if (locals) {\r\n            for (let [variableName, variableValue] of Object.entries(locals)) {\r\n                let uniqueBindVariableName = this._calculateRenderingIterationAwareUniqueName(variableName);\r\n\r\n                props[uniqueBindVariableName] = variableValue;\r\n                bindVariables.push(uniqueBindVariableName);\r\n\r\n                // Replace variables with unique name (needs be done incrementally instead of\r\n                // global matching regex, because global matching regex selects to much\r\n                // with one pattern and as a consequence would pass on some matches)\r\n                let replacedHtml = html;\r\n                do {\r\n                    html = replacedHtml;\r\n                    \r\n                    // Local \"updated\" variable that references global derived property?\r\n                    if (uniqueBindVariableName in this)\r\n                        uniqueBindVariableName = \"this.\" + uniqueBindVariableName;\r\n\r\n                    replacedHtml = html.replace(new RegExp(`([{][^{}]*[^\\\\w]|[{])${variableName}([^\\\\w])`), `$1${uniqueBindVariableName}$2`);\r\n                } while (replacedHtml.length != html.length)\r\n            }\r\n        }\r\n\r\n        // Make derived global bind variables observable\r\n        const regexp = new RegExp('this((\\\\.\\\\w+)*)\\\\.(\\\\w+)[^\\\\w(]', 'g');\r\n        let prop = null;\r\n        for (const [, path, , expr] of html.matchAll(regexp)) {\r\n            let propObj = props;\r\n            if (path) {\r\n                const properties = path.split(\".\");\r\n                for (prop of properties)\r\n                    if (prop != \"\")\r\n                        propObj = propObj[prop] || this._derivedProperties[prop].call(this);\r\n            }\r\n\r\n            if (this._derivedProperties[prop]) // Derived property of component (function wrapped to support propertyReferences)?\r\n                html = this._makeDerivedVariablesObservable(`this${path}`, expr, this._derivedProperties[prop].toString(), html, false);\r\n            else if (path && Object.getOwnPropertyDescriptor(propObj, expr).get && !Object.getOwnPropertyDescriptor(propObj, expr).set) // Derived component of nested/store object property (not wrapped)?\r\n                html = this._makeDerivedVariablesObservable(`this${path}`, expr,\r\n                    Object.getOwnPropertyDescriptor(propObj, expr).get.toString(), html, false);\r\n        }\r\n\r\n        // Encode html tags within expressions because otherwise the parser parses them as separate elements\r\n        // (e.g. <div>() => `${this.persons.length > 0 ? \"<h2>Filtered list</h2>\" : \"\"}</div> would be parsed as div and h2 tags)\r\n        html = this._escapeTagsInExpressions(html);\r\n\r\n        return [html, bindVariables];\r\n    }\r\n\r\n    _escapeTagsInExpressions(html: string) {\r\n        const stringTokens = [\"\\\"\", \"'\", \"`\"];\r\n\r\n        for (let stringToken of stringTokens) {\r\n            let stringExpressions = html.match(new RegExp(`${stringToken}[^${stringToken}]+${stringToken}`, \"g\"));\r\n            if (stringExpressions)\r\n                for (let match of stringExpressions)\r\n                    if (match.includes(\"<\")) html = html.replace(match, match.replaceAll(\"<\", \"&lt;\"));\r\n            }\r\n\r\n        return html;\r\n    }\r\n\r\n    _processElementBinding(element: DOMElement, bindVariables: PropertyMap, bindVariableNames: string[]) {\r\n        // Support databinding expressions in attributes (regular DOM elements)\r\n        if (\"attributes\" in element)\r\n            Array.from(element.attributes).forEach((attr: Attr) => {\r\n                if (attr.nodeValue.includes(\"${\"))\r\n                    this._processBindingExpression(element, bindVariables, bindVariableNames, attr.nodeName, attr.nodeValue);\r\n            });\r\n\r\n        // Support databinding expressions within tags (TextNodes)\r\n        if (\"data\" in element) {\r\n            if (element.data.includes(\"${\"))\r\n                this._processTextNodeBinding(element, bindVariables, bindVariableNames, element.data);\r\n        }\r\n\r\n        // Edit child elements recursively\r\n        if (\"childNodes\" in element)\r\n            for (const childElement of Array.from(element.childNodes))\r\n                this._processElementBinding(childElement, bindVariables, bindVariableNames);\r\n\r\n        // Render elements with render support      \r\n        if (element instanceof HofHtmlElement)\r\n            element.render();\r\n    }\r\n\r\n    _processTextNodeBinding(textNode: Text, bindVariables: PropertyMap, bindVariableNames: string[], expr: string) {\r\n        // Replace text nodes with span elements to support rendering of html content by expressions\r\n        if (textNode.parentNode) {\r\n            var replacementNode = document.createElement('span');\r\n            textNode.parentNode.insertBefore(replacementNode, textNode);\r\n            textNode.parentNode.removeChild(textNode);\r\n\r\n            this._processBindingExpression(replacementNode, bindVariables, bindVariableNames, \"innerHTML\", expr);\r\n        }\r\n        else\r\n            this._processBindingExpression(textNode, bindVariables, bindVariableNames, \"data\", textNode.data);\r\n    }\r\n\r\n    _processBindingExpression(element: DOMElement, bindVariables: PropertyMap, bindVariableNames: string[], attr: string, expr: string) {\r\n        // Build callable expression to (re)calculate value of attribute based on depending binding variables  \r\n        let attributeExpression = null;\r\n        try {\r\n            attributeExpression = this._buildCallableExpression(attr, expr, bindVariableNames);\r\n        }\r\n        catch (e) {\r\n            throw Error(`Expression '${expr}' of [${element.nodeName}].${attr} cannot be resolved. `\r\n                + `Perhaps you have forgotten some double quotes around attribute ${attr} in template of component [${this.nodeName}] `\r\n                + `or you used double quotes within double quotes of an element attribute, e.g. <element attr=\"\\${ \"\" }\"></element>. `\r\n                + `Double quotes within template literals are currently not supported. Use single quotes or backticks instead!` );\r\n        }\r\n\r\n        // Save attribute expression for later execution on bind variable changes\r\n        if (!this._observerExpressions.has(element)) this._observerExpressions.set(element, new Map());\r\n        this._observerExpressions.get(element).set(attr, attributeExpression);\r\n\r\n        // Rebind this of subproperties to parent property\r\n        for (let bindVariableName of attributeExpression.bindVariableNames)\r\n            if (bindVariables[bindVariableName]?.bind)\r\n                bindVariables[bindVariableName] = bindVariables[bindVariableName].bind(this); // pass this from parent to child on callbacks that are passed down\r\n\r\n        // Determine current values\r\n        const bindVariableValues = this._getBindVariableValues(attributeExpression.bindVariableNames);\r\n\r\n        // Get current value of element attribute by evaluating expression\r\n        let value = attributeExpression.execute(...bindVariableValues);\r\n\r\n        // Check if attribute expression could be resolved\r\n        // (expression must always return value or null)\r\n        if (typeof value == \"undefined\")\r\n            throw Error(`Cannot resolve component template expression ${attributeExpression.template}! Please check if all referenced properties are defined within your component implementation!`)\r\n\r\n        if (value?.[\"bind\"]) // If value is function, then bind\r\n            value = value.bind(this);\r\n\r\n        // Set value\r\n        element[attr] = value;\r\n\r\n        // Register combination of element and attribute as observer for each bind variable name\r\n        if (value != null && !value[\"bind\"]) // Do not observe functions\r\n            this._registerElementAttributeAsObserverForBindVariables(element, attr, bindVariables, attributeExpression.bindVariableNames);\r\n    }\r\n\r\n    _buildCallableExpression(attr: string, expr: string, bindVariableNames: string[]) {\r\n        // If expression is the only expression, do not interpret it as string,\r\n        // but evaluate directly so that references to functions can be assigned to properties\r\n        if (attr == \"data\" || expr.lastIndexOf(\"${\") > 0 || expr.lastIndexOf(\"}\") < expr.length - 1)\r\n            expr = \"`\" + expr + \"`\";\r\n        else\r\n            expr = expr.replaceAll(\"${\", \"\").replaceAll(\"}\", \"\");\r\n\r\n        let referencedBindVariables = [];\r\n        for (const bindVariableName of bindVariableNames) {\r\n            if (expr.includes(bindVariableName))\r\n                referencedBindVariables.push(bindVariableName);\r\n        }\r\n\r\n        // Currently, in addition to the local variables (additional variables passed to renderContent/renderList),\r\n        // the WebComponent's properties are also passed as local variables to the WebComponent's attribute function,\r\n        // which is not really necessary, but facilitates the generic handling\r\n        return new AttributeExpression(new Function(...referencedBindVariables, \"return \" + expr).bind(this), referencedBindVariables, expr);\r\n    }\r\n\r\n    _registerElementAttributeAsObserverForBindVariables(element: DOMElement, attr: string, bindVariables: PropertyMap, referencedBindVariableNames: string[]) {\r\n        // Add combination of element and attribute to observer structure\r\n        for (let bindVariableName of referencedBindVariableNames) {\r\n            if (!this._observersForBindVariable.has(bindVariableName)) this._observersForBindVariable.set(bindVariableName, new Map());\r\n\r\n            const variableObservable = this._observersForBindVariable.get(bindVariableName);\r\n            if (!variableObservable.has(element)) variableObservable.set(element, []);\r\n\r\n            if (bindVariables[bindVariableName].bind)\r\n                bindVariables[bindVariableName] = bindVariables[bindVariableName].bind(this); // pass this from parent to child on callbacks that are passed down\r\n\r\n            variableObservable.get(element).push(attr);\r\n        }\r\n    }\r\n\r\n    _getBindVariableValues(bindVariableNames: string[]) {\r\n        let result = [];\r\n        for (const b of bindVariableNames)\r\n            result.push(this._allBindVariables[b]);\r\n\r\n        return result;\r\n    }\r\n\r\n    _updatePropertyObservers(bindVariable: [string, Object]) {\r\n        const [bindVariableName, bindVariableValue] = bindVariable;\r\n\r\n        // Render partially only if element has already been created (Setters should also be able to be called before component\r\n        // has been created for the first time, which is why state setters only change state here, but have no effect on UI yet).\r\n        if (this._observersForBindVariable.has(bindVariableName)) {\r\n            for (const [element, attrs] of this._observersForBindVariable.get(bindVariableName).entries()) {\r\n                // Remove removed components from bindings\r\n                if (typeof this._observerExpressions.get(element) == \"undefined\") {\r\n                    this._observersForBindVariable.get(bindVariableName).delete(element);\r\n                    continue;\r\n                };\r\n\r\n                for (const attrName of attrs) {\r\n                    const attrExpr = this._observerExpressions.get(element).get(attrName);\r\n\r\n                    if (!bindVariableValue.lastActionPropertyPath || attrExpr.template.includes(bindVariableValue.lastActionPropertyPath)) {\r\n                        // Reevaluate binding expression\r\n                        const bindVariableValues = this._getBindVariableValues(attrExpr.bindVariableNames);\r\n                        const newValue = attrExpr.execute(...bindVariableValues);\r\n\r\n                        // Always propagate changes in properties to all observer elements and propagate changes in subproperties only\r\n                        // if subproperty is included in binding expression / template (e.g. if data.selectedPerson.name is changed, only\r\n                        // attributes with bindings to data, data.selectedPerson and data.selectedPerson.name, but e.g. not on data.selectedPerson.age).\r\n                        if (typeof newValue.lastActionIndex != \"undefined\" || !bindVariableValue.lastActionPropertyPath || attrExpr.template && attrExpr.template.includes(bindVariableValue.lastActionPropertyPath)) {                               \r\n                            if (element[attrName] != newValue) {\r\n                                element[attrName] = newValue;\r\n\r\n                                // Log rerendering of non HofHtmlElements because they include no detailed logging like HofHtmlElements do\r\n                                if (!(element instanceof HofHtmlElement))\r\n                                    HofLogging.logRenderUpdate(element, attrName, newValue, \"Full rerender\");\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// render function for single html expressions\r\nexport function item(htmlRenderFunc: Function) { return htmlRenderFunc; }\r\n\r\n// render function for list html expressions\r\nexport function list(list: Array<Object>, htmlRenderFunc: Function, parentElement: string = \"div\", renderParentElementOnEmptyList: boolean = false) {\r\n    return { list, htmlRenderFunc, parentElement, renderParentElementOnEmptyList }; }\r\n\r\n// html template literal, that does not change expression but enables syntax highlighting\r\nexport const html = (strings: TemplateStringsArray, ...exprs: Object[]) => processTemplate(strings, exprs);\r\n\r\n// html template literal, that does not change expression but enables syntax highlighting\r\nexport const css = (strings: TemplateStringsArray, ...exprs: Object[]) => processTemplate(strings, exprs);\r\n\r\n// Template literal that does not change expression\r\n// https://github.com/lleaff/tagged-template-noop/blob/master/index.js\r\nfunction processTemplate(strings: TemplateStringsArray, exprs: Object[]) {\r\n    const lastIndex = strings.length - 1;\r\n    return strings.slice(0, lastIndex).reduce((p, s, i) => p + s + exprs[i], '') + strings[lastIndex];\r\n}\r\n\r\nclass HofLogging {\r\n    public static logPropertyUpdates: boolean;\r\n    public static logInitialRenderings: boolean;\r\n    public static logRenderUpdates: boolean;\r\n\r\n    public static setDebugging(debugging: boolean) {\r\n        HofLogging.logPropertyUpdates = debugging;\r\n        HofLogging.logInitialRenderings = debugging;\r\n        HofLogging.logRenderUpdates = debugging\r\n    }\r\n\r\n    static logPropertyUpdate(element: DOMElement, name: string, value: Object) {\r\n        // Dont log parent property changes since only child props are really updated because of partial rendering\r\n        // and these are additionally logged\r\n        if (HofLogging.logPropertyUpdates && (!value.lastActionPropertyPath || value.lastActionPropertyPath.endsWith(name)))\r\n            HofLogging.logElementActivity(element, name, value, \"Update\");\r\n    }\r\n\r\n    static logInitialRendering(element: DOMElement, renderIteration: number, properties: PropertyMap) {\r\n        if (HofLogging.logInitialRenderings && renderIteration == 0)\r\n            for (const prop of Object.keys(properties))\r\n                HofLogging.logElementActivity(element, prop, properties[prop], \"Initial render\");\r\n    }\r\n\r\n    static logRenderUpdate(element: DOMElement, name: string, value: Object, mode: string) {\r\n        if (HofLogging.logRenderUpdates)\r\n            HofLogging.logElementActivity(element, name, value, mode);\r\n    }\r\n\r\n    static logElementActivity(element: DOMElement, name: string, value: Object, mode: string) {\r\n        // Save lastActionObject for output because derivedProperties mapping function resets it\r\n        const lastActionObject = value.lastActionObject;\r\n\r\n        // Filter out function references that are not derived properties on first rendering because they are not observed\r\n        if (value[\"bind\"]) return;\r\n\r\n        // No update was required because rendered part of array did not change\r\n        if (value.lastActionMethod == \"NONE\") return;\r\n\r\n        console.log(`${HofLogging._calculateElementDisplayName(element as ParentNode)}: ${mode} of property ${name}: `\r\n            + `${value.lastActionMethod ?? \"SET\"} ${JSON.stringify(lastActionObject ?? value)}`);\r\n    }\r\n\r\n    static _calculateElementDisplayName(element: ParentNode) {\r\n        let elementName = element.nodeName ?? \"TEXT\";\r\n\r\n        if (element instanceof HofHtmlElement)\r\n            return elementName + \"[\" + element._instanceId + \"]\";\r\n        \r\n        // Look for HofHtmlElements above this HofHtmlElement\r\n        for (let node: ParentNode = element; node; node = node.parentNode) {\r\n            if (node.toString() === \"[object ShadowRoot]\" && node[\"host\"] instanceof HofHtmlElement)\r\n                elementName = node[\"host\"].nodeName + \"[\" + node[\"host\"]._instanceId + \"]\" + \">\" + elementName; // HofHtmlElement that contains this HofHtmlElement was found\r\n        }\r\n\r\n        return elementName;\r\n    }\r\n}\r\n\r\nHofLogging.setDebugging(true);", "// File, which is used to import library via regular import mechanism\r\n// but then adding imported entities to the window object\r\n// so that even without modules the JavaScript code will be executed\r\n// and can be used directly in a web application (this file is used\r\n// by esbuild to create nomodule version of this library)\r\n\r\n// Import elements of library\r\nimport { HofHtmlElement, item, list, html, css } from '../hof'\r\n\r\n// Make elements of library accessible on the window object\r\n(window as any).HofHtmlElement = HofHtmlElement;\r\n(window as any).item = item;\r\n(window as any).list = list;\r\n(window as any).html = html;\r\n(window as any).css = css;"],
  "mappings": "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",
  "names": []
}
